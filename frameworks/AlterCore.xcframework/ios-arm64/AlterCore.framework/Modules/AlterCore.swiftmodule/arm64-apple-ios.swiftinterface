// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name AlterCore
import AVFoundation
import AVKit

import CoreGraphics
import CoreMedia
import CoreVideo
import Foundation
import Metal
import MetalKit
import Photos
import QuartzCore
import Swift
import UIKit
import VideoToolbox
@objc @_inheritsConvenienceInitializers open class AvatarView : AlterCore.BasicRendererView, AlterCore.AvatarViewInterface {
  public var _wrappedAvatarViewInterface: Swift.AnyObject {
    get
  }
  public var avatar: AlterCore.Avatar?
  public var avatarController: AlterCore.AvatarController?
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public func setOnFrameListener(_ onFrame: @escaping (Swift.Float) -> Swift.Void)
  @objc override dynamic public func layoutSubviews()
  @objc override dynamic public func didMoveToSuperview()
  @objc override dynamic public func didMoveToWindow()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class CameraWrapper : ObjectiveC.NSObject {
  public var automaticallyAdjustOrientation: Swift.Bool
  @discardableResult
  public func start(frontFacing: Swift.Bool = true) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func addOnFrameListener(_ listener: @escaping (CoreMedia.CMSampleBuffer) -> Swift.Void)
  public func changeOrientation(_ newOrientation: UIKit.UIDeviceOrientation = UIDevice.current.orientation)
  public var imageOrientation: ImageIO.CGImagePropertyOrientation {
    get
  }
  public var frameResolution: (Swift.Int, Swift.Int) {
    get
  }
  public var paused: Swift.Bool {
    get
  }
  public func toggleFlash()
  @discardableResult
  public func pause() -> AlterCore.Future<Swift.Void>
  @discardableResult
  public func resume() -> AlterCore.Future<Swift.Void>
  @discardableResult
  public func stop() -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func switchLowLight(lowLightOn: Swift.Bool)
  @objc deinit
  @objc override dynamic public init()
}
extension CameraWrapper : AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
}
extension UIColor {
  public var rgbComponents: (red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat) {
    get
  }
}
extension Int {
  public var n: Swift.Float {
    get
  }
}
extension Float {
  public var n: Swift.Float {
    get
  }
}
extension Double {
  public var n: Swift.Float {
    get
  }
}
extension FacemojiAPIClass {
  @discardableResult
  public func initialize(_ apiKey: Swift.String) -> AlterCore.Future<Swift.Bool>
}
public class KotlinError : Foundation.LocalizedError, Swift.CustomStringConvertible {
  final public let exception: AlterCore.KotlinException
  public init(_ exception: AlterCore.KotlinException)
  public var errorDescription: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
  @objc deinit
}
extension Try {
  public func rethrow() throws -> T
}
extension AvatarRenderer {
  public func fixedZReprojector() -> AlterCore.FaceTrackerReprojector
}
extension TrackerAvatarController {
  @discardableResult
  public func updateFromCamera(_ sampleBuffer: CoreMedia.CMSampleBuffer) -> AlterCore.FaceTrackerResult?
  @discardableResult
  public func updateFromCamera(_ buffer: CoreVideo.CVPixelBuffer) -> AlterCore.FaceTrackerResult?
  public static func create(_ avatar: AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>) -> AlterCore.Future<AlterCore.Try<AlterCore.TrackerAvatarController>>
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class MetalTextureView : MetalKit.MTKView {
  public enum Rotation : Swift.Int {
    case rotate0Degrees
    case rotate90Degrees
    case rotate180Degrees
    case rotate270Degrees
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public var mirrorHorizontally: Swift.Bool {
    get
    set(value)
  }
  public var imageFill: AlterCore.FillMode
  public var pixelBuffer: CoreVideo.CVPixelBuffer? {
    get
    set(value)
  }
  public func setSampleBuffer(_ sampleBuffer: CoreMedia.CMSampleBuffer)
  public func setPixelBuffer(_ newBuffer: CoreVideo.CVPixelBuffer)
  @objc override dynamic public func draw(_ rect: CoreGraphics.CGRect)
  @objc deinit
}
@available(*, deprecated, message: "Renamed to BasicRendererViewDelegate")
public typealias FacemojiViewRenderDelegate = AlterCore.BasicRendererViewDelegate
public protocol BasicRendererViewDelegate : AnyObject {
  func render(_ surface: AlterCore.PlatformRenderingSurface)
}
public protocol FrameDropDelegate : AnyObject {
  func onFrameDrop(_ requestedFrameTimeMs: Swift.Double, _ renderFrameTimeMs: Swift.Double) -> Swift.Bool
}
@available(*, deprecated, message: "Renamed to BasicRendererView")
public typealias FacemojiBasicView = AlterCore.BasicRendererView
@objc @_inheritsConvenienceInitializers open class BasicRendererView : UIKit.UIView {
  weak public var renderDelegate: AlterCore.BasicRendererViewDelegate? {
    get
    set(value)
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  weak public var frameDropDelegate: AlterCore.FrameDropDelegate?
  public var preferredFramesPerSecond: Swift.Float {
    get
    set(value)
  }
  @objc override dynamic public func didMoveToSuperview()
  @objc override dynamic public func didMoveToWindow()
  public var synchronizeWithUI: Swift.Bool {
    get
    set(value)
  }
  public func render()
  @objc override dynamic public func layoutSubviews()
  public func startRecording(recordSound: Swift.Bool = true, desiredFps: Swift.Int = 30) -> AlterCore.Try<AlterCore.ViewRecorder>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinObjectWrapper {
  @objc deinit
}
public protocol ConvertibleToKotlin {
  init(_ wrapped: AlterCore.KotlinObjectWrapper)
  func asKotlin() -> Swift.AnyObject
}
public func listOf<T>(_ items: T...) -> [T]
public func floatArrayOf(_ items: Swift.Float...) -> [Swift.Float]
public func intArrayOf(_ items: Swift.Int...) -> [Swift.Int]
public func doubleArrayOf(_ items: Swift.Double...) -> [Swift.Double]
public func floatArrayOf(_ items: Swift.Float...) -> AlterCore.KotlinFloatArray
public func intArrayOf(_ items: Swift.Int...) -> AlterCore.KotlinIntArray
public func doubleArrayOf(_ items: Swift.Double...) -> AlterCore.KotlinDoubleArray
public func assert(_ condition: Swift.Bool)
public func numArrayOf(_ elements: AlterCore.KotlinDoubleArray) -> AlterCore.KotlinFloatArray
public func numArrayOf(_ elements_: AlterCore.KotlinFloatArray) -> AlterCore.KotlinFloatArray
public func numArrayOf(_ elements__: AlterCore.KotlinIntArray) -> AlterCore.KotlinFloatArray
public func min<T>(_ a: T, _ b: T) -> T where T : AlterCore.Vec
public func max<T>(_ a: T, _ b: T) -> T where T : AlterCore.Vec
public func deserializeResult(_ data: AlterCore.KotlinByteArray) -> AlterCore.KotlinPair<AlterCore.FaceTrackerResult, AlterCore.KotlinByteArray?>
extension File {
  public func readLines() -> AlterCore.Future<AlterCore.Try<[Swift.String]>>
}
public func imageFromBytes(_ bytes: AlterCore.KotlinByteArray) -> AlterCore.Future<AlterCore.Try<AlterCore.Image>>
public func uiImageFromBytes(_ bytes: AlterCore.KotlinByteArray) -> AlterCore.Try<AlterCore.UIKitImage>
extension FileSystem {
  public func subSystem(_ root: AlterCore.Path) -> AlterCore.FileSystem
}
extension WriteableFileSystem {
  public func subSystem(_ root_: AlterCore.Path) -> AlterCore.WriteableFileSystem
}
extension FileSystem {
  public func indexed(_ indexReloadIntervalMs: Swift.Int = 60 * 60 * 1000) -> AlterCore.FileSystem
}
extension WriteableFileSystem {
  public func indexed(_ indexReloadIntervalMs_: Swift.Int = 60 * 60 * 1000) -> AlterCore.WriteableFileSystem
}
extension FileSystem {
  public func textAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.String>>
}
extension FileSystem {
  public func watcher(_ watchFilter: ((Swift.String) -> Swift.Bool)? = nil, _ errorSensitivity: AlterCore.FileWatchErrorSensitivity = .medium) -> AlterCore.FileSystemWatcher
}
public func defaultBundle() -> Foundation.Bundle
public func createDevice(_ config: AlterCore.DeviceConfig) -> AlterCore.Try<AlterCore.Device>
extension FileSystem {
  public func readImageList(_ images: Any) -> AlterCore.Future<AlterCore.Try<AlterCore.ImageList>>
}
extension FileSystem {
  public func readImageCube(_ xPos: AlterCore.Path, _ xNeg: AlterCore.Path, _ yPos: AlterCore.Path, _ yNeg: AlterCore.Path, _ zPos: AlterCore.Path, _ zNeg: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.ImageCube>>
}
public func avatarDataUrlFromKey(_ key: Swift.String) -> Swift.String
public func createAvatarRenderer(_ avatarRendererConfig: AlterCore.AvatarRendererConfig, _ bundledFileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>
extension AvatarRenderer {
  public func drawUIImage(_ width: Swift.Int, _ height: Swift.Int, _ superSampling: Swift.Float = Float(2), _ flipY: Swift.Bool = false) -> AlterCore.Try<UIKit.UIImage>
}
extension AvatarRenderer {
  public func setBackgroundImage(_ image: CoreVideo.CVBuffer, _ fillMode: AlterCore.FillMode)
}
extension AvatarRenderer {
  public func setBackgroundImage(_ image: Metal.MTLTexture, _ fillMode_: AlterCore.FillMode)
}
extension AvatarRenderer {
  public func setBackgroundImage(_ image: UIKit.UIImage, _ fillMode__: AlterCore.FillMode)
}
extension AvatarRenderer {
  public func setOverlayImage(_ image: CoreVideo.CVBuffer, _ fillMode: AlterCore.FillMode)
}
extension AvatarRenderer {
  public func setOverlayImage(_ image: Metal.MTLTexture, _ fillMode_: AlterCore.FillMode)
}
extension AvatarRenderer {
  public func setOverlayImage(_ image: UIKit.UIImage, _ fillMode__: AlterCore.FillMode)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image: CoreVideo.CVBuffer)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image_: Metal.MTLTexture)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image__: UIKit.UIImage)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image: CoreVideo.CVBuffer)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image_: Metal.MTLTexture)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image__: UIKit.UIImage)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: CoreVideo.CVBuffer, _ backgroundColor: AlterCore.Col)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: Metal.MTLTexture, _ backgroundColor_: AlterCore.Col)
}
extension AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: UIKit.UIImage, _ backgroundColor__: AlterCore.Col)
}
public func getTimeMillis() -> Swift.Int64
public var ALTER_CORE_VERSION: Swift.String {
  get
}
@available(*, deprecated, message: "Renamed to ALTER_CORE_VERSION")
public var FACEMOJI_SDK_VERSION: Swift.String {
  get
}
public var PIf: Swift.Float {
  get
}
public var PIn: Swift.Float {
  get
}
public var radianPerDegree: Swift.Float {
  get
}
public var degreePerRadian: Swift.Float {
  get
}
public var EXPRESSION_BLENDSHAPES: [Swift.String] {
  get
}
@_hasMissingDesignatedInitializers public class Camera : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var viewMatrix: AlterCore.Mat4 {
    get
  }
  public var eye: AlterCore.Vec3 {
    get
  }
  public var origin: AlterCore.Vec3 {
    get
  }
  public var view: AlterCore.Vec3 {
    get
  }
  public var orbit: Swift.Bool {
    get
  }
  public var orbitRadius: Swift.Float {
    get
  }
  public func orthoNormalized() -> AlterCore.Camera
  public func forward(_ speed: Swift.Float = 1.n) -> AlterCore.Camera
  public func backward(_ speed: Swift.Float = 1.n) -> AlterCore.Camera
  public func right(_ speed: Swift.Float = 1.n) -> AlterCore.Camera
  public func left(_ speed: Swift.Float = 1.n) -> AlterCore.Camera
  public func up(_ speed: Swift.Float = 1.n, _ upOverride: AlterCore.Vec3? = nil) -> AlterCore.Camera
  public func down(_ speed: Swift.Float = 1.n, _ upOverride: AlterCore.Vec3? = nil) -> AlterCore.Camera
  public func lookTo(_ viewDirection: AlterCore.Vec3, _ verticalUp: AlterCore.Vec3? = nil) -> AlterCore.Camera
  public func lookAt(_ target: AlterCore.Vec3, _ verticalUp: AlterCore.Vec3? = nil) -> AlterCore.Camera
  public func rotate(_ azimuth: Swift.Float, _ zenith: Swift.Float, _ verticalUp: AlterCore.Vec3 = Vec3.zAxis, _ zenithLimit: Swift.Float? = 0.01.n) -> AlterCore.Camera
  public func rotate(_ heading: Swift.Float, _ elevation: Swift.Float, _ bank: Swift.Float) -> AlterCore.Camera
  public func withOrigin(_ origin: AlterCore.Vec3) -> AlterCore.Camera
  public func withView(_ view: AlterCore.Vec3) -> AlterCore.Camera
  public func withUp(_ up: AlterCore.Vec3) -> AlterCore.Camera
  public func withOrbit(_ orbit: Swift.Bool) -> AlterCore.Camera
  public func withOrbitRadius(_ orbitRadius: Swift.Float) -> AlterCore.Camera
  public static func lookTo(_ origin: AlterCore.Vec3, _ viewDirection: AlterCore.Vec3, _ upDirection: AlterCore.Vec3, _ orbit: Swift.Bool = false, _ orbitRadius: Swift.Float? = nil) -> AlterCore.Camera
  public static func lookAt(_ lookFrom: AlterCore.Vec3, _ lookAt: AlterCore.Vec3, _ upDirection: AlterCore.Vec3, _ orbit: Swift.Bool = false) -> AlterCore.Camera
  public static func == (lhs: AlterCore.Camera, rhs: AlterCore.Camera) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class OrbitCameraControls : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var camera: AlterCore.Camera {
    get
  }
  public func tick(_ delta: Swift.Float) -> AlterCore.OrbitCameraControls
  public static func from(_ basePosition: AlterCore.Vec3, _ targetPosition: AlterCore.Vec3, _ timeToRotate: Swift.Float, _ rotationalAxis: AlterCore.Vec3 = Vec3.zAxis) -> AlterCore.OrbitCameraControls
  public static func == (lhs: AlterCore.OrbitCameraControls, rhs: AlterCore.OrbitCameraControls) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Vec {
  typealias T = Self
  var _wrappedVec: Swift.AnyObject { get }
  func plus(_ rhs: Self.T) -> Self
  func plus(_ rhs_: Swift.Double) -> Self
  func plus(_ rhs__: Swift.Float) -> Self
  func minus(_ rhs: Self.T) -> Self
  func minus(_ rhs_: Swift.Double) -> Self
  func minus(_ rhs__: Swift.Float) -> Self
  func times(_ rhs: Swift.Double) -> Self
  func times(_ rhs_: Swift.Float) -> Self
  func times(_ rhs__: Self.T) -> Self
  func div(_ rhs: Swift.Double) -> Self
  func div(_ rhs_: Swift.Float) -> Self
  func div(_ rhs__: Self.T) -> Self
  func unaryMinus() -> Self
  func invDiv(_ rhs: Swift.Double) -> Self
  func invDiv(_ rhs_: Swift.Float) -> Self
  func sum() -> Swift.Float
  func length() -> Swift.Float
  func lengthSquared() -> Swift.Float
  func min() -> Swift.Float
  func max() -> Swift.Float
  func dot(_ rhs: Self.T) -> Swift.Float
  func normalized() -> Self?
  func normalized(_ default: Self.T) -> Self
  func elementWise(_ rhs: Self.T, _ operation: AlterCore.VecBinaryOperator) -> Self
  func elementWise(_ operation: AlterCore.VecUnaryOperator) -> Self
  func zero() -> Self
  func one() -> Self
  func floatArray() -> AlterCore.KotlinFloatArray
}
@_hasMissingDesignatedInitializers public class VecWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Vec {
  public typealias T = AlterCore.VecWrapper
  public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func plus(_ rhs: AlterCore.VecWrapper.T) -> Self
  public func plus(_ rhs_: Swift.Double) -> Self
  public func plus(_ rhs__: Swift.Float) -> Self
  public func minus(_ rhs: AlterCore.VecWrapper.T) -> Self
  public func minus(_ rhs_: Swift.Double) -> Self
  public func minus(_ rhs__: Swift.Float) -> Self
  public func times(_ rhs: Swift.Double) -> Self
  public func times(_ rhs_: Swift.Float) -> Self
  public func times(_ rhs__: AlterCore.VecWrapper.T) -> Self
  public func div(_ rhs: Swift.Double) -> Self
  public func div(_ rhs_: Swift.Float) -> Self
  public func div(_ rhs__: AlterCore.VecWrapper.T) -> Self
  public func unaryMinus() -> Self
  public func invDiv(_ rhs: Swift.Double) -> Self
  public func invDiv(_ rhs_: Swift.Float) -> Self
  public func sum() -> Swift.Float
  public func length() -> Swift.Float
  public func lengthSquared() -> Swift.Float
  public func min() -> Swift.Float
  public func max() -> Swift.Float
  public func dot(_ rhs: AlterCore.VecWrapper.T) -> Swift.Float
  public func normalized() -> Self?
  public func normalized(_ default: AlterCore.VecWrapper.T) -> Self
  public func elementWise(_ rhs: AlterCore.VecWrapper.T, _ operation: AlterCore.VecBinaryOperator) -> Self
  public func elementWise(_ operation: AlterCore.VecUnaryOperator) -> Self
  public func zero() -> Self
  public func one() -> Self
  public func floatArray() -> AlterCore.KotlinFloatArray
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vector : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, AlterCore.Vec {
  public typealias T = AlterCore.Vector
  public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ elements: AlterCore.KotlinFloatArray)
  public func factory(_ elements: AlterCore.KotlinFloatArray) -> Self
  public func plus(_ rhs: AlterCore.Vector.T) -> Self
  public func plus(_ rhs_: Swift.Double) -> Self
  public func plus(_ rhs__: Swift.Float) -> Self
  public func minus(_ rhs: AlterCore.Vector.T) -> Self
  public func minus(_ rhs_: Swift.Double) -> Self
  public func minus(_ rhs__: Swift.Float) -> Self
  public func times(_ rhs__: AlterCore.Vector.T) -> Self
  public func times(_ rhs: Swift.Double) -> Self
  public func times(_ rhs_: Swift.Float) -> Self
  public func div(_ rhs__: AlterCore.Vector.T) -> Self
  public func div(_ rhs: Swift.Double) -> Self
  public func div(_ rhs_: Swift.Float) -> Self
  public func unaryMinus() -> Self
  public func invDiv(_ rhs: Swift.Double) -> Self
  public func invDiv(_ rhs_: Swift.Float) -> Self
  public func sum() -> Swift.Float
  public func length() -> Swift.Float
  public func lengthSquared() -> Swift.Float
  public func min() -> Swift.Float
  public func max() -> Swift.Float
  public func dot(_ rhs: AlterCore.Vector.T) -> Swift.Float
  public func normalized() -> Self?
  public func normalized(_ default: AlterCore.Vector.T) -> Self
  public func elementWise(_ rhs: AlterCore.Vector.T, _ operation: AlterCore.VecBinaryOperator) -> Self
  public func elementWise(_ operation: AlterCore.VecUnaryOperator) -> Self
  public func zero() -> Self
  public func one() -> Self
  public func floatArray() -> AlterCore.KotlinFloatArray
  public func asList() -> [Swift.Float]
  public func vecMulMat<M>(_ mat: M) -> Self where M : AlterCore.Matrix
  public static func matMulVec<M, V>(_ mat: M, _ vec: V) -> V where M : AlterCore.Matrix, V : AlterCore.Vector
  public static func == (lhs: AlterCore.Vector, rhs: AlterCore.Vector) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Col : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ r: Swift.Double, _ g: Swift.Double, _ b: Swift.Double, _ a: Swift.Double)
  public convenience init(_ r: Swift.Double, _ g: Swift.Double, _ b: Swift.Double)
  public convenience init(_ r: Swift.Float, _ g: Swift.Float, _ b: Swift.Float, _ a_: Swift.Float)
  public convenience init(_ r: Swift.Float, _ g: Swift.Float, _ b_: Swift.Float)
  public convenience init(_ r: Swift.Int, _ g: Swift.Int, _ b: Swift.Int, _ a__: Swift.Int)
  public convenience init(_ r: Swift.Int, _ g: Swift.Int, _ b__: Swift.Int)
  public convenience init()
  public convenience init(_ color: Swift.Int, _ channelMap: AlterCore.KotlinIntArray = RGB)
  public var r: Swift.Float {
    get
  }
  public var g: Swift.Float {
    get
  }
  public var b: Swift.Float {
    get
  }
  public var a: Swift.Float {
    get
  }
  public var rgb: AlterCore.Col {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public static var RGBA: AlterCore.KotlinIntArray {
    get
  }
  public static var BGRA: AlterCore.KotlinIntArray {
    get
  }
  public static var RGB: AlterCore.KotlinIntArray {
    get
  }
  public static var BGR: AlterCore.KotlinIntArray {
    get
  }
  public static var WHITE: AlterCore.Col {
    get
  }
  public static var BLACK: AlterCore.Col {
    get
  }
  public static var TRANSPARENT: AlterCore.Col {
    get
  }
  public static var RED: AlterCore.Col {
    get
  }
  public static var GREEN: AlterCore.Col {
    get
  }
  public static var BLUE: AlterCore.Col {
    get
  }
  public static var MAGENTA: AlterCore.Col {
    get
  }
  public static var YELLOW: AlterCore.Col {
    get
  }
  public static var CYAN: AlterCore.Col {
    get
  }
  public static var GRAY: AlterCore.Col {
    get
  }
  public func withR(_ r: Swift.Float) -> AlterCore.Col
  public func withG(_ g: Swift.Float) -> AlterCore.Col
  public func withB(_ b: Swift.Float) -> AlterCore.Col
  public func withA(_ a: Swift.Float) -> AlterCore.Col
  public func toInt(_ channelMap: AlterCore.KotlinIntArray = RGBA) -> Swift.Int
  public func clamp() -> AlterCore.Col
  public static func fromHex(_ hex: Swift.String) -> AlterCore.Try<AlterCore.Col>
  public static func == (lhs: AlterCore.Col, rhs: AlterCore.Col) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MatrixLayout : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public var transposed: AlterCore.MatrixLayout {
    get
  }
  public static var default_: AlterCore.MatrixLayout {
    get
  }
  public func invoke(_ row: Swift.Int, _ column: Swift.Int, _ order: Swift.Int) -> Swift.Int
  public static func == (lhs: AlterCore.MatrixLayout, rhs: AlterCore.MatrixLayout) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension MatrixLayout {
  @_hasMissingDesignatedInitializers public class RowMajorClass : AlterCore.MatrixLayout {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    override public var transposed: AlterCore.MatrixLayout {
      get
    }
    public static func == (lhs: AlterCore.MatrixLayout.RowMajorClass, rhs: AlterCore.MatrixLayout.RowMajorClass) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
  public static var RowMajor: AlterCore.MatrixLayout.RowMajorClass {
    get
  }
}
extension MatrixLayout {
  @_hasMissingDesignatedInitializers public class ColumnMajorClass : AlterCore.MatrixLayout {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    override public var transposed: AlterCore.MatrixLayout {
      get
    }
    public static func == (lhs: AlterCore.MatrixLayout.ColumnMajorClass, rhs: AlterCore.MatrixLayout.ColumnMajorClass) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
  public static var ColumnMajor: AlterCore.MatrixLayout.ColumnMajorClass {
    get
  }
}
@_hasMissingDesignatedInitializers public class Matrix : AlterCore.Vector {
  public typealias T = AlterCore.Matrix
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ elements: AlterCore.KotlinFloatArray, _ order: Swift.Int, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public var order: Swift.Int {
    get
  }
  public var layout: AlterCore.MatrixLayout {
    get
  }
  public func factory(_ elements: AlterCore.KotlinFloatArray, _ order: Swift.Int, _ layout: AlterCore.MatrixLayout) -> Self
  public func transposed() -> Self
  public func transposedLayout() -> Self
  public func mul(_ rhs: AlterCore.Matrix.T) -> Self
  public func inverse() -> Self?
  public func inverse(_ default: AlterCore.Matrix.T) -> Self
  public static func == (lhs: AlterCore.Matrix, rhs: AlterCore.Matrix) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  override public var description: Swift.String {
    get
  }
  override public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Mat2 : AlterCore.Matrix {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ x: AlterCore.Vec2, _ y: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public convenience init(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public var x: AlterCore.Vec2 {
    get
  }
  public var y: AlterCore.Vec2 {
    get
  }
  public var mat2: AlterCore.Mat2 {
    get
  }
  public var mat3: AlterCore.Mat3 {
    get
  }
  public var mat4: AlterCore.Mat4 {
    get
  }
  public func withX(_ x: AlterCore.Vec2) -> AlterCore.Mat2
  public func withY(_ y: AlterCore.Vec2) -> AlterCore.Mat2
  public func withZ(_ z: AlterCore.Vec3) -> AlterCore.Mat3
  public func mul(_ rhs_: AlterCore.Vec2) -> AlterCore.Vec2
  public func scale() -> AlterCore.Vec2
  public static func identity(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func scale(_ x: Swift.Double, _ y: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func scale(_ x: Swift.Float, _ y: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func scale(_ vec: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func translate(_ x: Swift.Double, _ y: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func translate(_ x: Swift.Float, _ y: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func translate(_ vec: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func rotate(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func rotate(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func == (lhs: AlterCore.Mat2, rhs: AlterCore.Mat2) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Mat3 : AlterCore.Matrix {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ x: AlterCore.Vec3, _ y: AlterCore.Vec3, _ z: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public convenience init(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public var x: AlterCore.Vec3 {
    get
  }
  public var y: AlterCore.Vec3 {
    get
  }
  public var z: AlterCore.Vec3 {
    get
  }
  public var mat2: AlterCore.Mat2 {
    get
  }
  public var mat3: AlterCore.Mat3 {
    get
  }
  public var mat4: AlterCore.Mat4 {
    get
  }
  public func withX(_ x: AlterCore.Vec3) -> AlterCore.Mat3
  public func withY(_ y: AlterCore.Vec3) -> AlterCore.Mat3
  public func withZ(_ z: AlterCore.Vec3) -> AlterCore.Mat3
  public func withW(_ w: AlterCore.Vec4) -> AlterCore.Mat4
  public func mul(_ rhs_: AlterCore.Vec3) -> AlterCore.Vec3
  public func mul(_ rhs__: AlterCore.Quaternion) -> AlterCore.Mat3
  public func quaternion() -> AlterCore.Quaternion
  public func scale() -> AlterCore.Vec3
  public func scale2() -> AlterCore.Vec2
  public func translation() -> AlterCore.Vec2
  public func rotation() -> AlterCore.Quaternion
  public static func identity(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ x: Swift.Double, _ y: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ x: Swift.Float, _ y: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ vec: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ x: Swift.Double, _ y: Swift.Double? = nil, _ z: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ x: Swift.Float, _ y: Swift.Float? = nil, _ z: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ vec: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ x: Swift.Double, _ y: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ x: Swift.Float, _ y: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ vec: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ x: Swift.Double, _ y: Swift.Double? = nil, _ z: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ x: Swift.Float, _ y: Swift.Float? = nil, _ z: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ vec: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ angleX: Swift.Double, _ angleY: Swift.Double, _ angleZ: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ angleX: Swift.Float, _ angleY: Swift.Float, _ angleZ: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ angle: Swift.Double, _ axis: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ angle: Swift.Float, _ axis: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ cosAngle: Swift.Double, _ sinAngle: Swift.Double, _ axis: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ cosAngle: Swift.Float, _ sinAngle: Swift.Float, _ axis: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ v1: AlterCore.Vec3, _ v2: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateX(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateX(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateY(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateY(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateZ(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateZ(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func == (lhs: AlterCore.Mat3, rhs: AlterCore.Mat3) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Mat4 : AlterCore.Matrix {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ x: AlterCore.Vec4, _ y: AlterCore.Vec4, _ z: AlterCore.Vec4, _ w: AlterCore.Vec4, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public convenience init(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public var x: AlterCore.Vec4 {
    get
  }
  public var y: AlterCore.Vec4 {
    get
  }
  public var z: AlterCore.Vec4 {
    get
  }
  public var w: AlterCore.Vec4 {
    get
  }
  public var mat2: AlterCore.Mat2 {
    get
  }
  public var mat3: AlterCore.Mat3 {
    get
  }
  public var mat4: AlterCore.Mat4 {
    get
  }
  public func withX(_ x: AlterCore.Vec4) -> AlterCore.Mat4
  public func withY(_ y: AlterCore.Vec4) -> AlterCore.Mat4
  public func withZ(_ z: AlterCore.Vec4) -> AlterCore.Mat4
  public func withW(_ w: AlterCore.Vec4) -> AlterCore.Mat4
  public func mul(_ rhs_: AlterCore.Vec4) -> AlterCore.Vec4
  public func mul(_ rhs__: AlterCore.Quaternion) -> AlterCore.Mat4
  public func quaternion() -> AlterCore.Quaternion
  public func scale() -> AlterCore.Vec3
  public func translation() -> AlterCore.Vec3
  public func rotation() -> AlterCore.Quaternion
  public static func identity(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ x: Swift.Double, _ y: Swift.Double? = nil, _ z: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ x: Swift.Float, _ y: Swift.Float? = nil, _ z: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ vec: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ vec: AlterCore.Vec4, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ x: Swift.Double, _ y: Swift.Double? = nil, _ z: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ x: Swift.Float, _ y: Swift.Float? = nil, _ z: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ vec: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ vec: AlterCore.Vec4, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angleX: Swift.Double, _ angleY: Swift.Double, _ angleZ: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angleX: Swift.Float, _ angleY: Swift.Float, _ angleZ: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angleXYZ: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angle: Swift.Double, _ axis: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angle: Swift.Float, _ axis: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ cosAngle: Swift.Double, _ sinAngle: Swift.Double, _ axis: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ cosAngle: Swift.Float, _ sinAngle: Swift.Float, _ axis: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ v1: AlterCore.Vec3, _ v2: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateX(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateX(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateY(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateY(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateZ(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateZ(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func viewRH(_ eye: AlterCore.Vec3, _ view: AlterCore.Vec3, _ up: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func orthoRH(_ w: Swift.Double, _ h: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func orthoRH(_ w: Swift.Float, _ h: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func perspRH(_ fov: Swift.Double, _ aspect: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func perspRH(_ fov: Swift.Float, _ aspect: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func perspRHSymmetricZ(_ fov: Swift.Double, _ aspect: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func perspRHSymmetricZ(_ fov: Swift.Float, _ aspect: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func == (lhs: AlterCore.Mat4, rhs: AlterCore.Mat4) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Quaternion : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ r: Swift.Double, _ i: Swift.Double, _ j: Swift.Double, _ k: Swift.Double)
  public convenience init(_ r: Swift.Float, _ i: Swift.Float, _ j: Swift.Float, _ k_: Swift.Float)
  public convenience init(_ vec: AlterCore.Vec4)
  public convenience init()
  public var r: Swift.Float {
    get
  }
  public var i: Swift.Float {
    get
  }
  public var j: Swift.Float {
    get
  }
  public var k: Swift.Float {
    get
  }
  public var ijk: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public var mat3RowMajor: AlterCore.Mat3 {
    get
  }
  public var mat3ColumnMajor: AlterCore.Mat3 {
    get
  }
  public var mat4RowMajor: AlterCore.Mat4 {
    get
  }
  public var mat4ColumnMajor: AlterCore.Mat4 {
    get
  }
  public static var identity: AlterCore.Quaternion {
    get
  }
  public func withR(_ r: Swift.Float) -> AlterCore.Quaternion
  public func withI(_ i: Swift.Float) -> AlterCore.Quaternion
  public func withJ(_ j: Swift.Float) -> AlterCore.Quaternion
  public func withK(_ k: Swift.Float) -> AlterCore.Quaternion
  public func mul(_ rhs: AlterCore.Quaternion) -> AlterCore.Quaternion
  public func mul(_ rhs_: AlterCore.Mat3) -> AlterCore.Mat3
  public func mul(_ rhs__: AlterCore.Mat4) -> AlterCore.Mat4
  public func mul(_ rhs___: AlterCore.Vec3) -> AlterCore.Vec3
  public func inverse() -> AlterCore.Quaternion
  public func log() -> AlterCore.Quaternion
  public func exp() -> AlterCore.Quaternion
  public func toRotation() -> AlterCore.KotlinPair<Swift.Float, AlterCore.Vec3>
  public func toEuler() -> AlterCore.Vec3
  public func slerp(_ q: AlterCore.Quaternion, _ t: Swift.Float) -> AlterCore.Quaternion
  public func spline(_ q1: AlterCore.Quaternion, _ q2: AlterCore.Quaternion, _ q3: AlterCore.Quaternion, _ t: Swift.Float) -> AlterCore.Quaternion
  public func toMat3(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public func toMat4(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func fromMatrix(_ mat: AlterCore.Mat4) -> AlterCore.Quaternion
  public static func fromRotation(_ angle: Swift.Float, _ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> AlterCore.Quaternion
  public static func fromRotation(_ angle: Swift.Float, _ vec: AlterCore.Vec3) -> AlterCore.Quaternion
  public static func fromEuler(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> AlterCore.Quaternion
  public static func fromEuler(_ vec: AlterCore.Vec3) -> AlterCore.Quaternion
  public static func == (lhs: AlterCore.Quaternion, rhs: AlterCore.Quaternion) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  override public var description: Swift.String {
    get
  }
  override public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
public protocol VecUnaryOperator {
  var _wrappedVecUnaryOperator: Swift.AnyObject { get }
  func invoke(_ a: Swift.Float) -> Swift.Float
}
@_hasMissingDesignatedInitializers public class VecUnaryOperatorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.VecUnaryOperator {
  public var _wrappedVecUnaryOperator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func invoke(_ a: Swift.Float) -> Swift.Float
  @objc deinit
}
public protocol VecBinaryOperator {
  var _wrappedVecBinaryOperator: Swift.AnyObject { get }
  func invoke(_ a: Swift.Float, _ b: Swift.Float) -> Swift.Float
}
@_hasMissingDesignatedInitializers public class VecBinaryOperatorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.VecBinaryOperator {
  public var _wrappedVecBinaryOperator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func invoke(_ a: Swift.Float, _ b: Swift.Float) -> Swift.Float
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vec1 : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ x: Swift.Double)
  public convenience init(_ x_: Swift.Float)
  public convenience init(_ x__: Swift.Int)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public static var xAxis: AlterCore.Vec1 {
    get
  }
  public static var zero: AlterCore.Vec1 {
    get
  }
  public static var one: AlterCore.Vec1 {
    get
  }
  public func withX(_ x: Swift.Float) -> AlterCore.Vec1
  public func withY(_ y: Swift.Float) -> AlterCore.Vec2
  public static func == (lhs: AlterCore.Vec1, rhs: AlterCore.Vec1) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vec2 : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ x: Swift.Double, _ y: Swift.Double)
  public convenience init(_ x: Swift.Float, _ y_: Swift.Float)
  public convenience init(_ x: Swift.Int, _ y__: Swift.Int)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public static var xAxis: AlterCore.Vec2 {
    get
  }
  public static var yAxis: AlterCore.Vec2 {
    get
  }
  public static var zero: AlterCore.Vec2 {
    get
  }
  public static var one: AlterCore.Vec2 {
    get
  }
  public func withX(_ x: Swift.Float) -> AlterCore.Vec2
  public func withY(_ y: Swift.Float) -> AlterCore.Vec2
  public func withZ(_ z: Swift.Float) -> AlterCore.Vec3
  public func mul(_ mat: AlterCore.Mat2) -> AlterCore.Vec2
  public static func == (lhs: AlterCore.Vec2, rhs: AlterCore.Vec2) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vec3 : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double)
  public convenience init(_ x: Swift.Float, _ y: Swift.Float, _ z_: Swift.Float)
  public convenience init(_ x: Swift.Int, _ y: Swift.Int, _ z__: Swift.Int)
  public convenience init(_ xy: AlterCore.Vec2, _ z: Swift.Float)
  public convenience init(_ xyz: Swift.Float)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var z: Swift.Float {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public var rgb: AlterCore.Col {
    get
  }
  public static var xAxis: AlterCore.Vec3 {
    get
  }
  public static var yAxis: AlterCore.Vec3 {
    get
  }
  public static var zAxis: AlterCore.Vec3 {
    get
  }
  public static var zero: AlterCore.Vec3 {
    get
  }
  public static var one: AlterCore.Vec3 {
    get
  }
  public func withX(_ x: Swift.Float) -> AlterCore.Vec3
  public func withY(_ y: Swift.Float) -> AlterCore.Vec3
  public func withZ(_ z: Swift.Float) -> AlterCore.Vec3
  public func withW(_ w: Swift.Float) -> AlterCore.Vec4
  public func cross(_ rhs: AlterCore.Vec3) -> AlterCore.Vec3
  public func mul(_ mat: AlterCore.Mat3) -> AlterCore.Vec3
  public func mul(_ rhs: AlterCore.Quaternion) -> AlterCore.Vec3
  public static func == (lhs: AlterCore.Vec3, rhs: AlterCore.Vec3) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vec4 : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double)
  public convenience init(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w_: Swift.Float)
  public convenience init(_ x: Swift.Int, _ y: Swift.Int, _ z: Swift.Int, _ w__: Swift.Int)
  public convenience init(_ xy: AlterCore.Vec2, _ z: Swift.Float)
  public convenience init(_ xy: AlterCore.Vec2, _ z: Swift.Float, _ w: Swift.Float)
  public convenience init(_ xy: AlterCore.Vec2, _ zw: AlterCore.Vec2)
  public convenience init(_ xyz: AlterCore.Vec3)
  public convenience init(_ xyz: AlterCore.Vec3, _ w: Swift.Float)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var z: Swift.Float {
    get
  }
  public var w: Swift.Float {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public var rgb: AlterCore.Col {
    get
  }
  public var rgba: AlterCore.Col {
    get
  }
  public static var xAxis: AlterCore.Vec4 {
    get
  }
  public static var yAxis: AlterCore.Vec4 {
    get
  }
  public static var zAxis: AlterCore.Vec4 {
    get
  }
  public static var wAxis: AlterCore.Vec4 {
    get
  }
  public static var zero: AlterCore.Vec4 {
    get
  }
  public static var one: AlterCore.Vec4 {
    get
  }
  public func withX(_ x: Swift.Float) -> AlterCore.Vec4
  public func withY(_ y: Swift.Float) -> AlterCore.Vec4
  public func withZ(_ z: Swift.Float) -> AlterCore.Vec4
  public func withW(_ w: Swift.Float) -> AlterCore.Vec4
  public func dehomog() -> AlterCore.Vec3?
  public func mul(_ mat: AlterCore.Mat4) -> AlterCore.Vec4
  public static func == (lhs: AlterCore.Vec4, rhs: AlterCore.Vec4) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Try<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public var optional: T? {
    get
  }
  public var exception: AlterCore.KotlinException? {
    get
  }
  public var bool_: Swift.Bool {
    get
  }
  public var orThrow: T {
    get
  }
  public func flatMap<U>(_ mapper: @escaping (T) -> AlterCore.Try<U>) -> AlterCore.Try<U>
  public func map<U>(_ mapper: @escaping (T) -> U) -> AlterCore.Try<U>
  public func mapError(_ mapper: @escaping (AlterCore.KotlinException) -> AlterCore.KotlinException) -> AlterCore.Try<T>
  public func `catch`(_ catcher: @escaping (AlterCore.KotlinException) -> T) -> T
  public func catchError(_ catcher: @escaping (AlterCore.TryError) -> T) -> T
  public func or(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Try<T>) -> AlterCore.Try<T>
  public func flatten<TExt>() -> AlterCore.Try<TExt> where T : AlterCore.Try<TExt>
  public func logError(_ prefix: Swift.String? = nil) -> T?
  public func logWarning(_ prefix: Swift.String? = nil) -> T?
  public func logInfo(_ prefix: Swift.String? = nil) -> T?
  public func logDebug(_ prefix: Swift.String? = nil) -> T?
  public func logInternal(_ prefix: Swift.String? = nil) -> T?
  public func `defer`<TExt>() -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Future<TExt>
  public func defer_<TExt>() -> AlterCore.Observable<AlterCore.Try<TExt>> where T : AlterCore.Observable<TExt>
  public func squash<TExt>() -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Future<AlterCore.Try<TExt>>
  public static func invoke<T>(_ fn: @escaping () -> T) -> AlterCore.Try<T>
  public static func invoke<T>(_ errorContext: Swift.String, _ fn: @escaping () -> T) -> AlterCore.Try<T>
  public static func success<T>(_ value: T) -> AlterCore.Try<T>
  public static func error<T>(_ exception: AlterCore.KotlinException) -> AlterCore.Try<T>
  public static func error<T>(_ message: Swift.String) -> AlterCore.Try<T>
  public static func all<T>(_ items: [AlterCore.Try<T>]) -> AlterCore.Try<[T]>
  public static func == (lhs: AlterCore.Try<T>, rhs: AlterCore.Try<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TryValue<T> : AlterCore.Try<T>, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ value: T)
  public var value: T {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> T
  public func doCopy(_ value: T) -> AlterCore.TryValue<T>
  public static func == (lhs: AlterCore.TryValue<T>, rhs: AlterCore.TryValue<T>) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class TryError : AlterCore.Try<Swift.Never>, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ message: Swift.String)
  public convenience init(_ error: AlterCore.KotlinException)
  public var error: AlterCore.KotlinException {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.KotlinException
  public func doCopy(_ error: AlterCore.KotlinException) -> AlterCore.TryError
  public static func == (lhs: AlterCore.TryError, rhs: AlterCore.TryError) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
public protocol KotlinComparable {
  associatedtype T
  var _wrappedKotlinComparable: Swift.AnyObject { get }
  func compareTo(_ other: Self.T) -> Swift.Int
}
@_hasMissingDesignatedInitializers public class KotlinComparableWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.KotlinComparable {
  public typealias T = T
  public var _wrappedKotlinComparable: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func compareTo(_ other: T) -> Swift.Int
  @objc deinit
}
public enum FillMode : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case stretch
  case zoom
  case shrink
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.FillMode, b: AlterCore.FillMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum PixelComponents : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case r
  case rg
  case rgba
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.PixelComponents, b: AlterCore.PixelComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Image : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public static func == (lhs: AlterCore.Image, rhs: AlterCore.Image) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension Image {
  @_hasMissingDesignatedInitializers public class RawInt : AlterCore.Image {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ data: AlterCore.KotlinIntArray)
    override public var width: Swift.Int {
      get
    }
    override public var height: Swift.Int {
      get
    }
    public var data: AlterCore.KotlinIntArray {
      get
    }
    public static func == (lhs: AlterCore.Image.RawInt, rhs: AlterCore.Image.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension Image {
  @_hasMissingDesignatedInitializers public class RawFloat : AlterCore.Image {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ data: AlterCore.KotlinFloatArray, _ pixelComponents: AlterCore.PixelComponents)
    override public var width: Swift.Int {
      get
    }
    override public var height: Swift.Int {
      get
    }
    public var data: AlterCore.KotlinFloatArray {
      get
    }
    public var pixelComponents: AlterCore.PixelComponents {
      get
    }
    public static func == (lhs: AlterCore.Image.RawFloat, rhs: AlterCore.Image.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class ImageList : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public var images: [AlterCore.Image] {
    get
  }
  public static func == (lhs: AlterCore.ImageList, rhs: AlterCore.ImageList) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension ImageList {
  @_hasMissingDesignatedInitializers public class RawInt : AlterCore.ImageList {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ data: [AlterCore.KotlinIntArray])
    override public var images: [AlterCore.Image] {
      get
    }
    public static func == (lhs: AlterCore.ImageList.RawInt, rhs: AlterCore.ImageList.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ImageList {
  @_hasMissingDesignatedInitializers public class RawFloat : AlterCore.ImageList {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ data: [AlterCore.KotlinFloatArray], _ pixelComponents: AlterCore.PixelComponents)
    override public var images: [AlterCore.Image] {
      get
    }
    public static func == (lhs: AlterCore.ImageList.RawFloat, rhs: AlterCore.ImageList.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class ImageCube : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public static func == (lhs: AlterCore.ImageCube, rhs: AlterCore.ImageCube) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension ImageCube {
  @_hasMissingDesignatedInitializers public class RawInt : AlterCore.ImageCube {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public convenience init(_ size: Swift.Int, _ xPos: AlterCore.KotlinIntArray, _ xNeg: AlterCore.KotlinIntArray, _ yPos: AlterCore.KotlinIntArray, _ yNeg: AlterCore.KotlinIntArray, _ zPos: AlterCore.KotlinIntArray, _ zNeg: AlterCore.KotlinIntArray)
    public var xPos: AlterCore.Image.RawInt {
      get
    }
    public var xNeg: AlterCore.Image.RawInt {
      get
    }
    public var yPos: AlterCore.Image.RawInt {
      get
    }
    public var yNeg: AlterCore.Image.RawInt {
      get
    }
    public var zPos: AlterCore.Image.RawInt {
      get
    }
    public var zNeg: AlterCore.Image.RawInt {
      get
    }
    public static func == (lhs: AlterCore.ImageCube.RawInt, rhs: AlterCore.ImageCube.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ImageCube {
  @_hasMissingDesignatedInitializers public class RawFloat : AlterCore.ImageCube {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public convenience init(_ size: Swift.Int, _ xPos: AlterCore.KotlinFloatArray, _ xNeg: AlterCore.KotlinFloatArray, _ yPos: AlterCore.KotlinFloatArray, _ yNeg: AlterCore.KotlinFloatArray, _ zPos: AlterCore.KotlinFloatArray, _ zNeg: AlterCore.KotlinFloatArray, _ pixelComponents: AlterCore.PixelComponents)
    public var xPos: AlterCore.Image.RawFloat {
      get
    }
    public var xNeg: AlterCore.Image.RawFloat {
      get
    }
    public var yPos: AlterCore.Image.RawFloat {
      get
    }
    public var yNeg: AlterCore.Image.RawFloat {
      get
    }
    public var zPos: AlterCore.Image.RawFloat {
      get
    }
    public var zNeg: AlterCore.Image.RawFloat {
      get
    }
    public static func == (lhs: AlterCore.ImageCube.RawFloat, rhs: AlterCore.ImageCube.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class UIKitImage : AlterCore.Image {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ platformImage: UIKit.UIImage)
  override public var width: Swift.Int {
    get
  }
  override public var height: Swift.Int {
    get
  }
  public var platformImage: UIKit.UIImage {
    get
  }
  public static func == (lhs: AlterCore.UIKitImage, rhs: AlterCore.UIKitImage) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MetalImage : AlterCore.Image {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ texture: Metal.MTLTexture)
  override public var width: Swift.Int {
    get
  }
  override public var height: Swift.Int {
    get
  }
  public var texture: Metal.MTLTexture {
    get
  }
  public static func == (lhs: AlterCore.MetalImage, rhs: AlterCore.MetalImage) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FaceTrackerResult : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ blendshapes: [Swift.String : Swift.Float], _ normalizedImagePosition: AlterCore.Vec2, _ normalizedImageScale: Swift.Float, _ rotationQuaternion: AlterCore.Quaternion, _ confidence: Swift.Float, _ inputImageSize: AlterCore.Vec2, _ faceRectangle: AlterCore.Rect, _ positionInCrop: AlterCore.Vec2, _ scaleInCrop: Swift.Float, _ debug: Any? = nil)
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var normalizedImagePosition: AlterCore.Vec2 {
    get
  }
  public var normalizedImageScale: Swift.Float {
    get
  }
  public var rotationQuaternion: AlterCore.Quaternion {
    get
  }
  public var confidence: Swift.Float {
    get
  }
  public var inputImageSize: AlterCore.Vec2 {
    get
  }
  public var faceRectangle: AlterCore.Rect {
    get
  }
  public var debug: Any? {
    get
  }
  public static var EMPTY: AlterCore.FaceTrackerResult {
    get
  }
  public func hasFace() -> Swift.Bool
  public func interpolate(_ other: AlterCore.FaceTrackerResult, _ t: Swift.Float) -> AlterCore.FaceTrackerResult
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : Swift.Float]
  public func component2() -> AlterCore.Vec2
  public func component3() -> Swift.Float
  public func component4() -> AlterCore.Quaternion
  public func component5() -> Swift.Float
  public func component6() -> AlterCore.Vec2
  public func component7() -> AlterCore.Rect
  public func component10() -> Any?
  public func doCopy(_ blendshapes: [Swift.String : Swift.Float], _ normalizedImagePosition: AlterCore.Vec2, _ normalizedImageScale: Swift.Float, _ rotationQuaternion: AlterCore.Quaternion, _ confidence: Swift.Float, _ inputImageSize: AlterCore.Vec2, _ faceRectangle: AlterCore.Rect, _ positionInCrop: AlterCore.Vec2, _ scaleInCrop: Swift.Float, _ debug: Any? = nil) -> AlterCore.FaceTrackerResult
  public func serialize(_ customData: AlterCore.KotlinByteArray? = nil) -> AlterCore.KotlinByteArray
  public static func == (lhs: AlterCore.FaceTrackerResult, rhs: AlterCore.FaceTrackerResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerWithResult : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ tracker: AlterCore.PersistentFaceTracker, _ result: AlterCore.FaceTrackerResult?)
  public var tracker: AlterCore.PersistentFaceTracker {
    get
  }
  public var result: AlterCore.FaceTrackerResult? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.PersistentFaceTracker
  public func component2() -> AlterCore.FaceTrackerResult?
  public func doCopy(_ tracker: AlterCore.PersistentFaceTracker, _ result: AlterCore.FaceTrackerResult?) -> AlterCore.FaceTrackerWithResult
  public static func == (lhs: AlterCore.FaceTrackerWithResult, rhs: AlterCore.FaceTrackerWithResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerImage : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ image: CoreVideo.CVBuffer)
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var image: CoreVideo.CVBuffer {
    get
  }
  public func toUIImage() -> AlterCore.Try<UIKit.UIImage>
  public static func == (lhs: AlterCore.TrackerImage, rhs: AlterCore.TrackerImage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerGPUContext : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public static func == (lhs: AlterCore.TrackerGPUContext, rhs: AlterCore.TrackerGPUContext) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol PersistentFaceTracker {
  var _wrappedPersistentFaceTracker: Swift.AnyObject { get }
  var version: Swift.String { get }
  var blendshapeNames: [Swift.String] { get }
  func track(_ image: AlterCore.TrackerImage) -> AlterCore.FaceTrackerWithResult
}
@_hasMissingDesignatedInitializers public class PersistentFaceTrackerWrapper : AlterCore.ConvertibleToKotlin, AlterCore.PersistentFaceTracker {
  public var _wrappedPersistentFaceTracker: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var version: Swift.String {
    get
  }
  public var blendshapeNames: [Swift.String] {
    get
  }
  public func track(_ image: AlterCore.TrackerImage) -> AlterCore.FaceTrackerWithResult
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FaceTracker : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var lastResult: AlterCore.FaceTrackerResult? {
    get
  }
  public var blendshapeNames: [Swift.String] {
    get
  }
  public func track(_ image: AlterCore.TrackerImage) -> AlterCore.FaceTrackerResult?
  public static func createVideoTracker(_ fileSystem: AlterCore.FileSystem, _ context: AlterCore.TrackerGPUContext) -> AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>
  public static func createImageTracker(_ fileSystem: AlterCore.FileSystem, _ context: AlterCore.TrackerGPUContext) -> AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>
  public static func == (lhs: AlterCore.FaceTracker, rhs: AlterCore.FaceTracker) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol FaceTrackerFactory {
  var _wrappedFaceTrackerFactory: Swift.AnyObject { get }
  func create(_ fileSystem: AlterCore.FileSystem, _ context: AlterCore.TrackerGPUContext) -> AlterCore.Future<AlterCore.Try<AlterCore.PersistentFaceTracker>>
}
@_hasMissingDesignatedInitializers public class FaceTrackerFactoryWrapper : AlterCore.ConvertibleToKotlin, AlterCore.FaceTrackerFactory {
  public var _wrappedFaceTrackerFactory: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func create(_ fileSystem: AlterCore.FileSystem, _ context: AlterCore.TrackerGPUContext) -> AlterCore.Future<AlterCore.Try<AlterCore.PersistentFaceTracker>>
  @objc deinit
}
public protocol FaceTrackerReprojector {
  var _wrappedFaceTrackerReprojector: Swift.AnyObject { get }
  func reproject(_ trackerResult: AlterCore.FaceTrackerResult) -> AlterCore.FaceTrackerReprojectorResult
  func reproject(_ normalizedImagePosition: AlterCore.Vec2, _ normalizedImageScale: Swift.Float) -> AlterCore.FaceTrackerReprojectorResult
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.FaceTrackerReprojector {
  public var _wrappedFaceTrackerReprojector: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func reproject(_ trackerResult: AlterCore.FaceTrackerResult) -> AlterCore.FaceTrackerReprojectorResult
  public func reproject(_ normalizedImagePosition: AlterCore.Vec2, _ normalizedImageScale: Swift.Float) -> AlterCore.FaceTrackerReprojectorResult
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectorResult : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ spatialPosition: AlterCore.Vec3, _ spatialScale: Swift.Float)
  public var spatialPosition: AlterCore.Vec3 {
    get
  }
  public var spatialScale: Swift.Float {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.Vec3
  public func component2() -> Swift.Float
  public func doCopy(_ spatialPosition: AlterCore.Vec3, _ spatialScale: Swift.Float) -> AlterCore.FaceTrackerReprojectorResult
  public static func == (lhs: AlterCore.FaceTrackerReprojectorResult, rhs: AlterCore.FaceTrackerReprojectorResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectors : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public static func fixedZReprojector(_ fovDegrees: Swift.Float, _ widthToHeight: Swift.Float, _ avatarWidth: Swift.Float, _ z: Swift.Float) -> AlterCore.FaceTrackerReprojector
  public static func fixedZReprojector(_ fovDegrees: Swift.Float, _ renderingWidth: Swift.Int, _ renderingHeight: Swift.Int, _ imageWidth: Swift.Int, _ imageHeight: Swift.Int, _ fillMode: AlterCore.FillMode, _ avatarWidth: Swift.Float, _ z: Swift.Float) -> AlterCore.FaceTrackerReprojector
  public static func fixedScaleReprojector(_ fovDegrees: Swift.Float, _ widthToHeight: Swift.Float, _ avatarWidth: Swift.Float, _ scale: Swift.Float) -> AlterCore.FaceTrackerReprojector
  public static func fixedScaleReprojector(_ fovDegrees: Swift.Float, _ renderingWidth: Swift.Int, _ renderingHeight: Swift.Int, _ imageWidth: Swift.Int, _ imageHeight: Swift.Int, _ fillMode: AlterCore.FillMode, _ avatarWidth: Swift.Float, _ scale: Swift.Float) -> AlterCore.FaceTrackerReprojector
  public static func == (lhs: AlterCore.FaceTrackerReprojectors, rhs: AlterCore.FaceTrackerReprojectors) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Rect : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ x: Swift.Float, _ y: Swift.Float, _ width: Swift.Float, _ height: Swift.Float)
  public convenience init(_ origin: AlterCore.Vec2, _ size: AlterCore.Vec2)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var width: Swift.Float {
    get
  }
  public var height: Swift.Float {
    get
  }
  public var origin: AlterCore.Vec2 {
    get
  }
  public var extent: AlterCore.Vec2 {
    get
  }
  public var minX: Swift.Float {
    get
  }
  public var minY: Swift.Float {
    get
  }
  public var maxX: Swift.Float {
    get
  }
  public var maxY: Swift.Float {
    get
  }
  public static var FULL: AlterCore.Rect {
    get
  }
  public func area() -> Swift.Float
  public func expandToSquare() -> AlterCore.Rect
  public func scaleWidthHeight(_ sw: Swift.Float, _ sh: Swift.Float) -> AlterCore.Rect
  public func scaleXY(_ sx: Swift.Float, _ sy: Swift.Float) -> AlterCore.Rect
  public func scale(_ sx: Swift.Float, _ sy: Swift.Float) -> AlterCore.Rect
  public func scale(_ s: AlterCore.Vec2) -> AlterCore.Rect
  public func scaleAroundCenter(_ sx: Swift.Float, _ sy: Swift.Float) -> AlterCore.Rect
  public func offset(_ dx: Swift.Float, _ dy: Swift.Float) -> AlterCore.Rect
  public func flipY(_ maxHeight: Swift.Float = 1.n) -> AlterCore.Rect
  public func toArray() -> AlterCore.KotlinFloatArray
  public func toFloatArray() -> AlterCore.KotlinFloatArray
  public func insetBy(_ dx: Swift.Float, _ dy: Swift.Float) -> AlterCore.Rect
  public func normalizeBy(_ size: AlterCore.Vec2) -> AlterCore.Rect
  public static func == (lhs: AlterCore.Rect, rhs: AlterCore.Rect) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AssetListGenerator : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ fileSystem: AlterCore.FileSystem, _ device: AlterCore.Device, _ logFilter: ((Swift.String) -> Swift.Bool)? = nil)
  public func scanAssets(_ matrixPaths: Any, _ fileWithItemList: Swift.String) -> AlterCore.Future<AlterCore.Try<[Swift.String]>>
  public static func == (lhs: AlterCore.AssetListGenerator, rhs: AlterCore.AssetListGenerator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public enum GeneratorMode : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case position
  case rotation
  case scale
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.GeneratorMode, b: AlterCore.GeneratorMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol AvatarController {
  var _wrappedAvatarController: Swift.AnyObject { get }
  func frame() -> AlterCore.AvatarAnimationData?
}
@_hasMissingDesignatedInitializers public class AvatarControllerWrapper : AlterCore.ConvertibleToKotlin, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func frame() -> AlterCore.AvatarAnimationData?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class GeneratorController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ changeMode: AlterCore.GeneratorMode, _ renderer: AlterCore.AvatarRenderer, _ startingPosition: AlterCore.AvatarAnimationData)
  public func pointerMove(_ x: Swift.Float, _ y: Swift.Float)
  public func pointerDown(_ x: Swift.Float, _ y: Swift.Float)
  public func pointerUp(_ x: Swift.Float, _ y: Swift.Float)
  public func decreaseScale()
  public func increaseScale()
  public func frame() -> AlterCore.AvatarAnimationData?
  public func setGeneratorMode(_ mode: AlterCore.GeneratorMode)
  public static func == (lhs: AlterCore.GeneratorController, rhs: AlterCore.GeneratorController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemMetadataAndThumbnailGenerator : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var controller: AlterCore.GeneratorController {
    get
  }
  public func generateThumbnails(_ width: Swift.Int, _ height: Swift.Int, _ superSampling: Swift.Float, _ saveConfig: Swift.Bool = true)
  public static func create(_ loader: AlterCore.AvatarLoader, _ renderer: AlterCore.AvatarRenderer, _ fileSystem: AlterCore.WriteableFileSystem, _ itemReference: AlterCore.ItemReferenceDefinition, _ imageConvertor: @escaping (AlterCore.UIKitImage) -> AlterCore.KotlinByteArray) -> AlterCore.Future<AlterCore.Try<AlterCore.ItemMetadataAndThumbnailGenerator>>
  public static func == (lhs: AlterCore.ItemMetadataAndThumbnailGenerator, rhs: AlterCore.ItemMetadataAndThumbnailGenerator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ThumbnailConfigDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ matrix: AlterCore.AvatarMatrix, _ view: AlterCore.TransformDefinition, _ properties: [Swift.String : Swift.String] = [:])
  public var matrix: AlterCore.AvatarMatrix {
    get
  }
  public var view: AlterCore.TransformDefinition {
    get
  }
  public var properties: [Swift.String : Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.AvatarMatrix
  public func component2() -> AlterCore.TransformDefinition
  public func component3() -> [Swift.String : Swift.String]
  public func doCopy(_ matrix: AlterCore.AvatarMatrix, _ view: AlterCore.TransformDefinition, _ properties: [Swift.String : Swift.String] = [:]) -> AlterCore.ThumbnailConfigDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ThumbnailConfigDefinition
  public static func == (lhs: AlterCore.ThumbnailConfigDefinition, rhs: AlterCore.ThumbnailConfigDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol File {
  var _wrappedFile: Swift.AnyObject { get }
  var path: AlterCore.Path { get }
  var fileSystem: AlterCore.FileSystem { get }
  func readAllBytes() -> AlterCore.Future<AlterCore.Try<AlterCore.KotlinByteArray>>
  func readAllText() -> AlterCore.Future<AlterCore.Try<Swift.String>>
  func readImage() -> AlterCore.Future<AlterCore.Try<AlterCore.Image>>
}
@_hasMissingDesignatedInitializers public class FileWrapper : AlterCore.ConvertibleToKotlin, AlterCore.File {
  public var _wrappedFile: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var path: AlterCore.Path {
    get
  }
  public var fileSystem: AlterCore.FileSystem {
    get
  }
  public func readAllBytes() -> AlterCore.Future<AlterCore.Try<AlterCore.KotlinByteArray>>
  public func readAllText() -> AlterCore.Future<AlterCore.Try<Swift.String>>
  public func readImage() -> AlterCore.Future<AlterCore.Try<AlterCore.Image>>
  @objc deinit
}
public protocol FileSystem {
  var _wrappedFileSystem: Swift.AnyObject { get }
  var root: AlterCore.Path { get }
  func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
}
@_hasMissingDesignatedInitializers public class FileSystemWrapper : AlterCore.ConvertibleToKotlin, AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  @objc deinit
}
public protocol WriteableFileSystem : AlterCore.FileSystem {
  var _wrappedWriteableFileSystem: Swift.AnyObject { get }
  func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64?) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
}
@_hasMissingDesignatedInitializers public class WriteableFileSystemWrapper : AlterCore.ConvertibleToKotlin, AlterCore.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var root: AlterCore.Path {
    get
  }
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ApplicationContext : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ bundle: Foundation.Bundle = defaultBundle())
  public var bundle: Foundation.Bundle {
    get
  }
  public static func == (lhs: AlterCore.ApplicationContext, rhs: AlterCore.ApplicationContext) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ResourceFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public convenience init(_ context: AlterCore.ApplicationContext, _ root: AlterCore.Path)
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public static func create(_ context: AlterCore.ApplicationContext) -> AlterCore.ResourceFileSystem
  public static func create(_ context: AlterCore.ApplicationContext, _ root: AlterCore.Path) -> AlterCore.ResourceFileSystem
  public static func == (lhs: AlterCore.ResourceFileSystem, rhs: AlterCore.ResourceFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DeviceFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ root: AlterCore.Path)
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public static func create(_ root: AlterCore.Path) -> AlterCore.DeviceFileSystem
  public static func == (lhs: AlterCore.DeviceFileSystem, rhs: AlterCore.DeviceFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class NetworkFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: AlterCore.Path)
  public var session: Foundation.URLSession {
    get
  }
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public static func create(_ serverUrl: Swift.String) -> AlterCore.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool) -> AlterCore.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ root: AlterCore.Path) -> AlterCore.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: AlterCore.Path) -> AlterCore.NetworkFileSystem
  public static func == (lhs: AlterCore.NetworkFileSystem, rhs: AlterCore.NetworkFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class WriteableNetworkFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem, AlterCore.WriteableFileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: AlterCore.Path)
  public var root: AlterCore.Path {
    get
  }
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func watch(_ watchPaths: Swift.Set<Swift.String>) -> AlterCore.Future<Swift.Set<Swift.String>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public static func create(_ serverUrl: Swift.String) -> AlterCore.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool) -> AlterCore.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ root: AlterCore.Path) -> AlterCore.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: AlterCore.Path) -> AlterCore.WriteableNetworkFileSystem
  public static func == (lhs: AlterCore.WriteableNetworkFileSystem, rhs: AlterCore.WriteableNetworkFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileSubSystem<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem where T : AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ parent: T, _ newRoot: AlterCore.Path)
  public var root: AlterCore.Path {
    get
  }
  public var parent: T {
    get
  }
  public var newRoot: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public static func == (lhs: AlterCore.FileSubSystem<T>, rhs: AlterCore.FileSubSystem<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class WriteableFileSubSystem : AlterCore.FileSubSystem<AlterCore.WriteableFileSystemWrapper>, AlterCore.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  override public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ parent: AlterCore.WriteableFileSystem, _ newRoot: AlterCore.Path)
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public static func == (lhs: AlterCore.WriteableFileSubSystem, rhs: AlterCore.WriteableFileSubSystem) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FallbackFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ filesystems: AlterCore.KotlinArray<AlterCore.FileSystem>)
  public convenience init(_ filesystems_: [AlterCore.FileSystem])
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public static func == (lhs: AlterCore.FallbackFileSystem, rhs: AlterCore.FallbackFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DevelopmentFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem, AlterCore.WriteableFileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ root: AlterCore.Path, _ resourceDirsOverride: [Swift.String], _ port: Swift.String = "8000")
  public convenience init(_ root: AlterCore.Path = Path(""), _ resourceDirsOverride: AlterCore.KotlinArray<Swift.String>? = nil, _ port_: Swift.String = "8000")
  public var root: AlterCore.Path {
    get
  }
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func watch(_ watchPaths: Swift.Set<Swift.String>) -> AlterCore.Future<Swift.Set<Swift.String>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public static func == (lhs: AlterCore.DevelopmentFileSystem, rhs: AlterCore.DevelopmentFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileSystemWatcher : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ fileSystem: AlterCore.FileSystem, _ watchFilter: ((Swift.String) -> Swift.Bool)? = nil, _ errorSensitivity: AlterCore.FileWatchErrorSensitivity = .medium)
  public func watch<T>(_ noChangeValue: T, _ watcher: @escaping (AlterCore.FileSystem) -> T) -> T
  public func watch<T>(_ noChangeValue: T, _ fileSystem: AlterCore.FileSystem, _ watcher: @escaping (AlterCore.FileSystem) -> T) -> T
  public func watchFlat<T>(_ noChangeValue: T, _ watcher: @escaping (AlterCore.FileSystem) -> AlterCore.Future<T>) -> AlterCore.Future<T>
  public static func == (lhs: AlterCore.FileSystemWatcher, rhs: AlterCore.FileSystemWatcher) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public enum FileWatchErrorSensitivity : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case low
  case medium
  case high
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.FileWatchErrorSensitivity, b: AlterCore.FileWatchErrorSensitivity) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class JsonEncoderDecoderClass : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var json: AlterCore.Kotlinx_serialization_jsonJson {
    get
  }
  public func parseJson<T, TKotlinx_serialization_coreDeserializationStrategy>(_ jsonText: Swift.String, _ strategy: TKotlinx_serialization_coreDeserializationStrategy) -> AlterCore.Try<T> where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func encodeToString<T>(_ value: T) -> Swift.String
  public func decodeFromString<T>(_ value: Swift.String) -> AlterCore.Try<T>
  public static func == (lhs: AlterCore.JsonEncoderDecoderClass, rhs: AlterCore.JsonEncoderDecoderClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public var JsonEncoderDecoder: AlterCore.JsonEncoderDecoderClass
@_hasMissingDesignatedInitializers public class Path : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ path: Swift.String)
  public func lastComponent() -> Swift.String
  public func `extension`() -> Swift.String
  public func baseName() -> Swift.String
  public func directory() -> AlterCore.Path
  public func join(_ path: Swift.String) -> AlterCore.Path
  public func join(_ path_: AlterCore.Path) -> AlterCore.Path
  public func div(_ path: Swift.String) -> AlterCore.Path
  public func div(_ path_: AlterCore.Path) -> AlterCore.Path
  public func normalized() -> AlterCore.Path
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func doCopy(_ path: Swift.String) -> AlterCore.Path
  public static func == (lhs: AlterCore.Path, rhs: AlterCore.Path) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class CommonEmotionsClass : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var HAPPY: [Swift.String : Swift.Float] {
    get
  }
  public var SAD: [Swift.String : Swift.Float] {
    get
  }
  public var ANGRY: [Swift.String : Swift.Float] {
    get
  }
  public var VICIOUS: [Swift.String : Swift.Float] {
    get
  }
  public var SURPRISED: [Swift.String : Swift.Float] {
    get
  }
  public var SCARED: [Swift.String : Swift.Float] {
    get
  }
  public static func == (lhs: AlterCore.CommonEmotionsClass, rhs: AlterCore.CommonEmotionsClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public var CommonEmotions: AlterCore.CommonEmotionsClass
@_hasMissingDesignatedInitializers public class FacemojiAPIClass : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var isFullyActivated: Swift.Bool {
    get
  }
  public var isDemoMode: Swift.Bool {
    get
  }
  public func initialize(_ apiKey: Swift.String, _ context: AlterCore.ApplicationContext) -> AlterCore.Future<Swift.Bool>
  public func addDemoTimeoutCallback(_ cb: @escaping () -> Swift.Void)
  public static func == (lhs: AlterCore.FacemojiAPIClass, rhs: AlterCore.FacemojiAPIClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public var FacemojiAPI: AlterCore.FacemojiAPIClass
public enum LogLevel : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case `internal`
  case debug
  case info
  case warning
  case error
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.LogLevel, b: AlterCore.LogLevel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Logger : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public static var logLevel: AlterCore.LogLevel {
    get
    set(newValue)
  }
  public static var printLogWithListeners: Swift.Bool {
    get
    set(newValue)
  }
  public static func log(_ level: AlterCore.LogLevel, _ message: Swift.String, _ logStackTrace: AlterCore.KotlinException? = nil)
  public static func addLogListener(_ l: @escaping (AlterCore.LogLevel, Swift.String) -> Swift.Void)
  public static func removeLogListener(_ l: @escaping (AlterCore.LogLevel, Swift.String) -> Swift.Void)
  public static func time() -> AlterCore.TimeLogger
  public static func debug(_ message: Swift.String)
  public static func info(_ message: Swift.String)
  public static func warning(_ message: Swift.String)
  public static func error(_ message: Swift.String)
  public static func error(_ error: AlterCore.KotlinException)
  public static func error(_ message: Swift.String, _ error: AlterCore.KotlinException)
  public static func == (lhs: AlterCore.Logger, rhs: AlterCore.Logger) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TimeLogger : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ start: Swift.Int64 = getTimeMillis())
  public func log(_ level: AlterCore.LogLevel, _ message: Swift.String, _ logStackTrace: AlterCore.KotlinException? = nil)
  public func debug(_ message: Swift.String)
  public func `internal`(_ message: Swift.String)
  public func info(_ message: Swift.String)
  public func warning(_ message: Swift.String)
  public func error(_ message: Swift.String)
  public static func == (lhs: AlterCore.TimeLogger, rhs: AlterCore.TimeLogger) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DispatchQueue : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ name: Swift.String)
  public static var main: AlterCore.DispatchQueue {
    get
  }
  public static var current: AlterCore.DispatchQueue? {
    get
  }
  public static var globalAsync: AlterCore.DispatchQueue {
    get
  }
  public func queue(_ fn: @escaping () -> Swift.Void)
  public func targetsThisThread() -> Swift.Bool?
  public static func createSingleThreaded(_ name: Swift.String) -> AlterCore.DispatchQueue
  public static func createSystemQueue(_ name: Swift.String) -> AlterCore.DispatchQueue
  public static func == (lhs: AlterCore.DispatchQueue, rhs: AlterCore.DispatchQueue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PeriodicExecutor : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ intervalSeconds: Swift.Double, _ fn: @escaping () -> Swift.Void)
  public func cancel()
  public static func == (lhs: AlterCore.PeriodicExecutor, rhs: AlterCore.PeriodicExecutor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Future<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ generator: @escaping (@escaping (T) -> Swift.Void) -> Swift.Void)
  public convenience init(_ value: T)
  public var resolved: Swift.Bool {
    get
  }
  public var currentValue: T? {
    get
  }
  public func whenDone(_ consumer: @escaping (T) -> Swift.Void)
  public func peek(_ consumer: @escaping (T) -> Swift.Void) -> AlterCore.Future<T>
  public func map<U>(_ mapper: @escaping (T) -> U) -> AlterCore.Future<U>
  public func flatMap<U>(_ mapper: @escaping (T) -> AlterCore.Future<U>) -> AlterCore.Future<U>
  public func waitFor() -> T
  public func waitFor(_ timeoutMillis: Swift.Int) -> T?
  @discardableResult
  public func logError<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  @discardableResult
  public func logWarning<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  @discardableResult
  public func logInfo<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  @discardableResult
  public func logDebug<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  public func logInternal<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  public func mapTry<TExt, U>(_ mapper: @escaping (TExt) -> U) -> AlterCore.Future<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func mapTryFlat<TExt, U>(_ mapper: @escaping (TExt) -> AlterCore.Try<U>) -> AlterCore.Future<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func flatMapTry<TExt, U>(_ mapper: @escaping (TExt) -> AlterCore.Future<AlterCore.Try<U>>) -> AlterCore.Future<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func flatMapTryFlat<U>(_ mapper: @escaping (T) -> AlterCore.Try<AlterCore.Future<U>>) -> AlterCore.Future<AlterCore.Try<U>>
  public func mapError<TExt>(_ mapper: @escaping (AlterCore.KotlinException) -> AlterCore.KotlinException) -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public func `catch`<TExt>(_ catcher: @escaping (AlterCore.KotlinException) -> TExt) -> AlterCore.Future<TExt> where T : AlterCore.Try<TExt>
  public func orTry<TExt>(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Try<TExt>) -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public func orTryFlat<TExt>(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Future<AlterCore.Try<TExt>>) -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public static func any<T>(_ futures: AlterCore.KotlinArray<AlterCore.Future<T>>) -> AlterCore.Future<T>
  public static func all<T>(_ futures: [AlterCore.Future<T>]) -> AlterCore.Future<[T]>
  public static func async<T>(_ fn: @escaping () -> T) -> AlterCore.Future<T>
  public static func == (lhs: AlterCore.Future<T>, rhs: AlterCore.Future<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Observable<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ generator: @escaping (@escaping (T) -> Swift.Void, @escaping () -> Swift.Void) -> Swift.Void)
  public convenience init(_ futures: AlterCore.KotlinArray<AlterCore.Future<T>>)
  public convenience init(_ futures_: Any)
  public convenience init(_ value: T)
  public var first: AlterCore.Future<T> {
    get
  }
  public var value: T? {
    get
  }
  public var last: AlterCore.Future<T?> {
    get
  }
  public var id: Swift.Int {
    get
  }
  public func subscribe(_ observer: @escaping (T) -> Swift.Void)
  public func unsubscribe(_ observer: @escaping (T) -> Swift.Void)
  public func map<U>(_ mapper: @escaping (T) -> U) -> AlterCore.Observable<U>
  public func flatMap<U>(_ mapper: @escaping (T) -> AlterCore.Observable<U>) -> AlterCore.Observable<U>
  public func mapNotNull<U>(_ mapper: @escaping (T) -> U?) -> AlterCore.Observable<U>
  public func peek(_ fn: @escaping (T) -> Swift.Void) -> AlterCore.Observable<T>
  public func filter(_ fn: @escaping (T) -> Swift.Bool) -> AlterCore.Observable<T>
  public func zipSecond<U>(_ withValue: U) -> AlterCore.Observable<AlterCore.KotlinPair<T, U>>
  public func zipFirst<U>(_ withValue: U) -> AlterCore.Observable<AlterCore.KotlinPair<U, T>>
  public func zipMap<U>(_ mapper: @escaping (T) -> U) -> AlterCore.Observable<AlterCore.KotlinPair<T, U>>
  public func mapTry<TExt, U>(_ mapper: @escaping (TExt) -> U) -> AlterCore.Observable<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func mapTryFlat<TExt, U>(_ mapper: @escaping (TExt) -> AlterCore.Try<U>) -> AlterCore.Observable<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func flatMapTry<TExt, U>(_ mapper: @escaping (TExt) -> AlterCore.Observable<AlterCore.Try<U>>) -> AlterCore.Observable<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func flatMapTryFlat<U>(_ mapper: @escaping (T) -> AlterCore.Try<AlterCore.Observable<U>>) -> AlterCore.Observable<AlterCore.Try<U>>
  public func `catch`<TExt>(_ catcher: @escaping (AlterCore.KotlinException) -> TExt) -> AlterCore.Observable<TExt> where T : AlterCore.Try<TExt>
  public func orTry<TExt>(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Try<TExt>) -> AlterCore.Observable<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public func orTryFlat<TExt>(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Observable<AlterCore.Try<TExt>>) -> AlterCore.Observable<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public static func any<T>(_ observables: Any) -> AlterCore.Observable<T>
  public static func all<T>(_ observables: Any) -> AlterCore.Observable<[T]>
  public static func == (lhs: AlterCore.Observable<T>, rhs: AlterCore.Observable<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PlatformRenderingSurface : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ drawableProvider: (() -> QuartzCore.CAMetalDrawable?)?, _ userRenderTexture: Metal.MTLTexture? = nil, _ extraTextures: [Metal.MTLTexture] = [], _ synchronizeWithUI: Swift.Bool = false)
  public var onRenderedDelegate: (() -> Swift.Void)? {
    get
    set(newValue)
  }
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var userRenderTexture: Metal.MTLTexture? {
    get
  }
  public var extraTextures: [Metal.MTLTexture] {
    get
  }
  public var synchronizeWithUI: Swift.Bool {
    get
  }
  public var aspectRatio: Swift.Float {
    get
  }
  public func withDrawable<T>(_ fn: @escaping (QuartzCore.CAMetalDrawable?, Metal.MTLTexture) -> T) -> T?
  public static func == (lhs: AlterCore.PlatformRenderingSurface, rhs: AlterCore.PlatformRenderingSurface) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Device : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ framebufferCacheCapacity: Swift.Int, _ depthTextureCacheCapacity: Swift.Int, _ pipelineCacheCapacity: Swift.Int, _ device: Metal.MTLDevice)
  public var device: Metal.MTLDevice {
    get
  }
  public static func == (lhs: AlterCore.Device, rhs: AlterCore.Device) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DeviceConfig : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ framebufferCacheCapacity: Swift.Int, _ depthTextureCacheCapacity: Swift.Int, _ pipelineCacheCapacity: Swift.Int, _ metalDevice: Metal.MTLDevice)
  public var framebufferCacheCapacity: Swift.Int {
    get
  }
  public var depthTextureCacheCapacity: Swift.Int {
    get
  }
  public var pipelineCacheCapacity: Swift.Int {
    get
  }
  public var metalDevice: Metal.MTLDevice {
    get
  }
  public static func == (lhs: AlterCore.DeviceConfig, rhs: AlterCore.DeviceConfig) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloDeferred : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ resourceFs: AlterCore.ResourceFileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloDeferred, rhs: AlterCore.HelloDeferred) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloDeferredInstanced : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ resourceFs: AlterCore.ResourceFileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func watch()
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloDeferredInstanced, rhs: AlterCore.HelloDeferredInstanced) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloFiller : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ resourceFs: AlterCore.FileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloFiller, rhs: AlterCore.HelloFiller) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloFramebuffer : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloFramebuffer, rhs: AlterCore.HelloFramebuffer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloParticles : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ resourceFileSystem: AlterCore.FileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloParticles, rhs: AlterCore.HelloParticles) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloResources : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ resourceFs: AlterCore.ResourceFileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloResources, rhs: AlterCore.HelloResources) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloTexturesHotSwap : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ resourceFs: AlterCore.FileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloTexturesHotSwap, rhs: AlterCore.HelloTexturesHotSwap) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloTextures : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ resourceFs: AlterCore.FileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloTextures, rhs: AlterCore.HelloTextures) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloTriangle : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloTriangle, rhs: AlterCore.HelloTriangle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RendererViewWrapper : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ view: UIKit.UIView, _ device: Metal.MTLDevice)
  public var synchronizeWithUI: Swift.Bool {
    get
    set(newValue)
  }
  public var aspectRatio: Swift.Float {
    get
  }
  public func nextDrawable(_ extraTargetTextures: [Metal.MTLTexture] = []) -> AlterCore.PlatformRenderingSurface
  public func updateSize()
  public func destroy()
  public static func == (lhs: AlterCore.RendererViewWrapper, rhs: AlterCore.RendererViewWrapper) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AvatarRenderer {
  var _wrappedAvatarRenderer: Swift.AnyObject { get }
  var width: Swift.Int { get }
  var height: Swift.Int { get }
  var animations: [Swift.String] { get }
  func draw(_ surface: AlterCore.PlatformRenderingSurface)
  func drawImage(_ width: Swift.Int, _ height: Swift.Int, _ reuse: AlterCore.UIKitImage?, _ superSampling: Swift.Float, _ flipY: Swift.Bool, _ maxPhysicsIterations: Swift.Int) -> AlterCore.Try<AlterCore.UIKitImage>
  func updateView(_ width: Swift.Int, _ height: Swift.Int)
  func setLiveBlendshapes(_ blendshapes: [Swift.String : Swift.Float], _ smoothing: Swift.Float)
  func setAvatarPosition(_ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3, _ smoothing: Swift.Float)
  func setAvatarAnimationData(_ newData: AlterCore.AvatarAnimationData, _ smoothing: Swift.Float)
  func applyLoadedAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  @available(*, deprecated, renamed: "applyLoadedAvatarMatrix", message: "Deprecated for semantic reasons, use applyLoadedAvatarMatrix instead")
  func reloadAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  func startAnimation(_ animationName: Swift.String, _ numberOfRuns: Swift.Int?, _ startDelay: Swift.Float, _ onStopListener: ((Swift.String) -> Swift.Void)?)
  func stopAnimation(_ animationName: Swift.String)
  func stopAllAnimations()
  func hideAvatar()
  func showAvatar()
  func setBackgroundColor(_ color: AlterCore.Col)
  func setBackgroundImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  func setOverlayImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  func setBackgroundImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  func setBackgroundImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  func setBackgroundImageShrink(_ image: AlterCore.Image, _ backgroundColor: AlterCore.Col)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  func setOverlayImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  func setOverlayImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  func setOverlayImageShrink(_ image: AlterCore.Image)
  func removeOverlay()
  func setAnimatedLight(_ animatedLight: Swift.Bool)
  func clone() -> AlterCore.AvatarRenderer
  func fixedZReprojector(_ artisticScale: Swift.Float) -> AlterCore.FaceTrackerReprojector
  func fixedScaleReprojector(_ artisticScale: Swift.Float) -> AlterCore.FaceTrackerReprojector
  static func create(_ avatarRendererConfig: AlterCore.AvatarRendererConfig) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>
}
@_hasMissingDesignatedInitializers public class AvatarRendererWrapper : AlterCore.ConvertibleToKotlin, AlterCore.AvatarRenderer {
  public var _wrappedAvatarRenderer: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var animations: [Swift.String] {
    get
  }
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public func drawImage(_ width: Swift.Int, _ height: Swift.Int, _ reuse: AlterCore.UIKitImage? = nil, _ superSampling: Swift.Float = Float(2), _ flipY: Swift.Bool = false, _ maxPhysicsIterations: Swift.Int = 1) -> AlterCore.Try<AlterCore.UIKitImage>
  public func updateView(_ width: Swift.Int, _ height: Swift.Int)
  public func setLiveBlendshapes(_ blendshapes: [Swift.String : Swift.Float], _ smoothing: Swift.Float = Float(0.0))
  public func setAvatarPosition(_ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3, _ smoothing: Swift.Float = Float(0.0))
  public func setAvatarAnimationData(_ newData: AlterCore.AvatarAnimationData, _ smoothing: Swift.Float = Float(0.0))
  public func applyLoadedAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  @available(*, deprecated, renamed: "applyLoadedAvatarMatrix", message: "Deprecated for semantic reasons, use applyLoadedAvatarMatrix instead")
  public func reloadAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  public func startAnimation(_ animationName: Swift.String, _ numberOfRuns: Swift.Int? = nil, _ startDelay: Swift.Float = Float(0), _ onStopListener: ((Swift.String) -> Swift.Void)? = nil)
  public func stopAnimation(_ animationName: Swift.String)
  public func stopAllAnimations()
  public func hideAvatar()
  public func showAvatar()
  public func setBackgroundColor(_ color: AlterCore.Col)
  public func setBackgroundImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  public func setOverlayImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: AlterCore.Image, _ backgroundColor: AlterCore.Col)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageShrink(_ image: AlterCore.Image)
  public func removeOverlay()
  public func setAnimatedLight(_ animatedLight: Swift.Bool)
  public func clone() -> AlterCore.AvatarRenderer
  public func fixedZReprojector(_ artisticScale: Swift.Float = Float(1.0)) -> AlterCore.FaceTrackerReprojector
  public func fixedScaleReprojector(_ artisticScale: Swift.Float = Float(1.0)) -> AlterCore.FaceTrackerReprojector
  public static func create(_ avatarRendererConfig: AlterCore.AvatarRendererConfig) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Avatar : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarRenderer {
  public var _wrappedAvatarRenderer: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var loader: AlterCore.AvatarLoader {
    get
  }
  public var avatarMatrix: AlterCore.AvatarMatrix? {
    get
  }
  public var strictMode: Swift.Bool {
    get
    set(newValue)
  }
  public var bundledFileSystem: AlterCore.FileSystem {
    get
  }
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var animations: [Swift.String] {
    get
  }
  public func updateAvatarFromMatrix(_ avatarMatrix: AlterCore.AvatarMatrix) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarMatrix>>
  public func updateAvatarFromJson(_ json: Swift.String) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarMatrix>>
  public func updateAvatarFromFile(_ path: Swift.String, _ fileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarMatrix>>
  public func setFileSystem(_ fileSystem: AlterCore.FileSystem)
  public func clone() -> AlterCore.AvatarRenderer
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public func drawImage(_ width: Swift.Int, _ height: Swift.Int, _ reuse: AlterCore.UIKitImage? = nil, _ superSampling: Swift.Float = Float(2), _ flipY: Swift.Bool = false, _ maxPhysicsIterations: Swift.Int = 1) -> AlterCore.Try<AlterCore.UIKitImage>
  public func updateView(_ width: Swift.Int, _ height: Swift.Int)
  public func setLiveBlendshapes(_ blendshapes: [Swift.String : Swift.Float], _ smoothing: Swift.Float = Float(0.0))
  public func setAvatarPosition(_ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3, _ smoothing: Swift.Float = Float(0.0))
  public func setAvatarAnimationData(_ newData: AlterCore.AvatarAnimationData, _ smoothing: Swift.Float = Float(0.0))
  public func applyLoadedAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  @available(*, deprecated, renamed: "applyLoadedAvatarMatrix", message: "Deprecated for semantic reasons, use applyLoadedAvatarMatrix instead")
  public func reloadAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  public func startAnimation(_ animationName: Swift.String, _ numberOfRuns: Swift.Int? = nil, _ startDelay: Swift.Float = Float(0), _ onStopListener: ((Swift.String) -> Swift.Void)? = nil)
  public func stopAnimation(_ animationName: Swift.String)
  public func stopAllAnimations()
  public func hideAvatar()
  public func showAvatar()
  public func setBackgroundColor(_ color: AlterCore.Col)
  public func setBackgroundImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  public func setOverlayImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: AlterCore.Image, _ backgroundColor: AlterCore.Col)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageShrink(_ image: AlterCore.Image)
  public func removeOverlay()
  public func setAnimatedLight(_ animatedLight: Swift.Bool)
  public func fixedZReprojector(_ artisticScale: Swift.Float = Float(1.0)) -> AlterCore.FaceTrackerReprojector
  public func fixedScaleReprojector(_ artisticScale: Swift.Float = Float(1.0)) -> AlterCore.FaceTrackerReprojector
  public static func create(_ avatarRendererConfig: AlterCore.AvatarRendererConfig) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>
  public static func == (lhs: AlterCore.Avatar, rhs: AlterCore.Avatar) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarFactory : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var bundledFileSystem: AlterCore.FileSystem {
    get
  }
  public var dataFileSystem: AlterCore.FileSystem {
    get
  }
  public var avatarLoader: AlterCore.AvatarLoader {
    get
  }
  public var device: AlterCore.Device {
    get
  }
  public func createEmptyAvatar() -> AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>
  public func createAvatarFromMatrix(_ avatarMatrix: AlterCore.AvatarMatrix) -> AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>
  public func createAvatarFromJson(_ json: Swift.String) -> AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>
  public func createAvatarFromFile(_ path: Swift.String, _ fileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>
  public func parseAvatarMatrixFromFile(_ path: Swift.String, _ fileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarMatrix>>
  public func parseAvatarMatrixFromJson(_ json: Swift.String) -> AlterCore.Try<AlterCore.AvatarMatrix>
  public func parseAvatarMatricesFromFile(_ path: Swift.String, _ fileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<[AlterCore.AvatarMatrix]>>
  public func parseAvatarMatricesFromJson(_ json: Swift.String) -> AlterCore.Try<[AlterCore.AvatarMatrix]>
  public static func create(_ serverUrl: Swift.String, _ strictMode: Swift.Bool = false) -> AlterCore.Try<AlterCore.AvatarFactory>
  public static func create(_ dataFileSystem: AlterCore.FileSystem, _ strictMode: Swift.Bool = false) -> AlterCore.Try<AlterCore.AvatarFactory>
  public static func == (lhs: AlterCore.AvatarFactory, rhs: AlterCore.AvatarFactory) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarAnimationData : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ blendshapes: [Swift.String : Swift.Float], _ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3)
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var position: AlterCore.Vec3 {
    get
  }
  public var rotation: AlterCore.Quaternion {
    get
  }
  public var scale: AlterCore.Vec3 {
    get
  }
  public static var DEFAULT_AVATAR_POSITION: AlterCore.Vec3 {
    get
  }
  public static var EMPTY: AlterCore.AvatarAnimationData {
    get
  }
  public func interpolate(_ other: AlterCore.AvatarAnimationData, _ t: Swift.Float) -> AlterCore.AvatarAnimationData
  public func withBlendshapes(_ newBlendshapes: [Swift.String : Swift.Float], _ smoothing: Swift.Float) -> AlterCore.AvatarAnimationData
  public func withPosition(_ newPosition: AlterCore.Vec3, _ newRotation: AlterCore.Quaternion, _ newScale: AlterCore.Vec3, _ smoothing: Swift.Float) -> AlterCore.AvatarAnimationData
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : Swift.Float]
  public func component2() -> AlterCore.Vec3
  public func component3() -> AlterCore.Quaternion
  public func component4() -> AlterCore.Vec3
  public func doCopy(_ blendshapes: [Swift.String : Swift.Float], _ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3) -> AlterCore.AvatarAnimationData
  public static func == (lhs: AlterCore.AvatarAnimationData, rhs: AlterCore.AvatarAnimationData) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FallbackAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ mainController: AlterCore.AvatarController, _ fallbackController: AlterCore.AvatarController, _ inTransitionTimeMs: Swift.Int = 500, _ outTransitionTimeMs: Swift.Int = 2500)
  public func frame() -> AlterCore.AvatarAnimationData?
  public static func == (lhs: AlterCore.FallbackAvatarController, rhs: AlterCore.FallbackAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerResultAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ renderer: AlterCore.AvatarRenderer)
  public func frame() -> AlterCore.AvatarAnimationData?
  public func update(_ trackResult: AlterCore.FaceTrackerResult?)
  public static func create(_ renderer: AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>) -> AlterCore.Future<AlterCore.Try<AlterCore.TrackerResultAvatarController>>
  public static func == (lhs: AlterCore.TrackerResultAvatarController, rhs: AlterCore.TrackerResultAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ tracker: AlterCore.FaceTracker, _ renderer: AlterCore.AvatarRenderer)
  @discardableResult
  public func updateFromCamera(_ image: AlterCore.TrackerImage) -> AlterCore.FaceTrackerResult?
  public func frame() -> AlterCore.AvatarAnimationData?
  public static func create(_ tracker: AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>, _ renderer: AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>) -> AlterCore.Future<AlterCore.Try<AlterCore.TrackerAvatarController>>
  public static func create(_ tracker: AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>, _ avatar: AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>) -> AlterCore.Future<AlterCore.Try<AlterCore.TrackerAvatarController>>
  public static func == (lhs: AlterCore.TrackerAvatarController, rhs: AlterCore.TrackerAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AnimatingAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ definition: AlterCore.AvatarAnimationDefinition)
  public func frame() -> AlterCore.AvatarAnimationData?
  public static func == (lhs: AlterCore.AnimatingAvatarController, rhs: AlterCore.AnimatingAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class InteractiveAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ renderer: AlterCore.AvatarRenderer, _ startingPosition: AlterCore.AvatarAnimationData)
  public func frame() -> AlterCore.AvatarAnimationData?
  public func move(_ x: Swift.Float, _ y: Swift.Float)
  public func move(_ delta: AlterCore.Vec2)
  public func rotate(_ x: Swift.Float, _ y: Swift.Float)
  public func rotate(_ delta: AlterCore.Vec2)
  public func scale(_ x: Swift.Float, _ y: Swift.Float)
  public func scale(_ delta: AlterCore.Vec2)
  public static func == (lhs: AlterCore.InteractiveAvatarController, rhs: AlterCore.InteractiveAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarLoader : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ fileSystem: AlterCore.FileSystem, _ device: AlterCore.Device)
  public convenience init(_ fileSystem: AlterCore.FileSystem, _ device: AlterCore.Device, _ cacheJsons: Swift.Bool, _ cacheModels: Swift.Bool, _ cacheTextures: Swift.Bool)
  public convenience init(_ device: AlterCore.Device, _ serverUrl: Swift.String, _ context: AlterCore.ApplicationContext, _ cacheJsons: Swift.Bool, _ cacheModels: Swift.Bool, _ cacheTextures: Swift.Bool)
  public convenience init(_ device: AlterCore.Device, _ serverUrl: Swift.String, _ context: AlterCore.ApplicationContext)
  public var fileSystem: AlterCore.FileSystem {
    get
  }
  public var strictMode: Swift.Bool {
    get
  }
  public func withFileSystem(_ fileSystem: AlterCore.FileSystem) -> AlterCore.AvatarLoader
  public func withStrictMode(_ mode: Swift.Bool) -> AlterCore.AvatarLoader
  public func loadAvatarMatrix(_ fileSystem: AlterCore.FileSystem, _ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.LoadedAvatarMatrix>>
  public func loadAvatarMatrix(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.LoadedAvatarMatrix>>
  public func loadAvatarMatrix(_ matrix: Swift.String) -> AlterCore.Future<AlterCore.Try<AlterCore.LoadedAvatarMatrix>>
  public func loadAvatarMatrix(_ matrix_: AlterCore.AvatarMatrix) -> AlterCore.Future<AlterCore.Try<AlterCore.LoadedAvatarMatrix>>
  public static func parseAvatarMatrices(_ matricesJson: Swift.String) -> AlterCore.Try<[AlterCore.AvatarMatrix]>
  public static func parseAvatarMatrix(_ matrixJson: Swift.String) -> AlterCore.Try<AlterCore.AvatarMatrix>
  public static func == (lhs: AlterCore.AvatarLoader, rhs: AlterCore.AvatarLoader) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarRendererConfig : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var device: AlterCore.Device {
    get
  }
  public var context: AlterCore.ApplicationContext {
    get
  }
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public static func create(_ width: Swift.Int, _ height: Swift.Int, _ metalDevice: Metal.MTLDevice) -> AlterCore.Try<AlterCore.AvatarRendererConfig>
  public static func createDefault() -> AlterCore.Try<AlterCore.AvatarRendererConfig>
  public static func == (lhs: AlterCore.AvatarRendererConfig, rhs: AlterCore.AvatarRendererConfig) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AvatarViewInterface {
  var _wrappedAvatarViewInterface: Swift.AnyObject { get }
  var avatar: AlterCore.Avatar? { get set }
  var avatarController: AlterCore.AvatarController? { get set }
  func setOnFrameListener(_ onFrame: @escaping (Swift.Float) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class AvatarViewInterfaceWrapper : AlterCore.ConvertibleToKotlin, AlterCore.AvatarViewInterface {
  public var _wrappedAvatarViewInterface: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var avatar: AlterCore.Avatar? {
    get
    set(newValue)
  }
  public var avatarController: AlterCore.AvatarController? {
    get
    set(newValue)
  }
  public func setOnFrameListener(_ onFrame: @escaping (Swift.Float) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AnimationReferenceDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ name: Swift.String, _ numberOfRepeats: Swift.Int = 1)
  public var name: Swift.String {
    get
  }
  public var numberOfRepeats: Swift.Int {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> Swift.Int
  public func doCopy(_ name: Swift.String, _ numberOfRepeats: Swift.Int = 1) -> AlterCore.AnimationReferenceDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AnimationReferenceDefinition
  public static func == (lhs: AlterCore.AnimationReferenceDefinition, rhs: AlterCore.AnimationReferenceDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarAnimationFrame : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ timeSeconds: Swift.Float, _ blendshapes: [Swift.String : Swift.Float] = [:], _ transform: AlterCore.TransformDefinition = TransformDefinition())
  public var timeSeconds: Swift.Float {
    get
  }
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var transform: AlterCore.TransformDefinition {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AvatarAnimationFrame
  public static func == (lhs: AlterCore.AvatarAnimationFrame, rhs: AlterCore.AvatarAnimationFrame) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarAnimationDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ repeats: Swift.Int = 0, _ timesAreCumulative: Swift.Bool = false, _ frames: [AlterCore.AvatarAnimationFrame] = [])
  public var repeats: Swift.Int {
    get
  }
  public var timesAreCumulative: Swift.Bool {
    get
  }
  public var frames: [AlterCore.AvatarAnimationFrame] {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AvatarAnimationDefinition
  public static func == (lhs: AlterCore.AvatarAnimationDefinition, rhs: AlterCore.AvatarAnimationDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarMatrix : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ name: Swift.String? = nil, _ items: [AlterCore.ItemReferenceDefinition] = [], _ animations: [AlterCore.AnimationReferenceDefinition] = [], _ blendshapes: [Swift.String : Swift.Float] = [:], _ boneBlenderPresetWeights: [Swift.String : Swift.Float] = [:], _ boneBlenderWeights: [Swift.String : Swift.Float] = [:])
  public var name: Swift.String? {
    get
  }
  public var items: [AlterCore.ItemReferenceDefinition] {
    get
  }
  public var animations: [AlterCore.AnimationReferenceDefinition] {
    get
  }
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var boneBlenderPresetWeights: [Swift.String : Swift.Float] {
    get
  }
  public var boneBlenderWeights: [Swift.String : Swift.Float] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String?
  public func component2() -> [AlterCore.ItemReferenceDefinition]
  public func component3() -> [AlterCore.AnimationReferenceDefinition]
  public func component4() -> [Swift.String : Swift.Float]
  public func component5() -> [Swift.String : Swift.Float]
  public func component6() -> [Swift.String : Swift.Float]
  public func doCopy(_ name: Swift.String? = nil, _ items: [AlterCore.ItemReferenceDefinition] = [], _ animations: [AlterCore.AnimationReferenceDefinition] = [], _ blendshapes: [Swift.String : Swift.Float] = [:], _ boneBlenderPresetWeights: [Swift.String : Swift.Float] = [:], _ boneBlenderWeights: [Swift.String : Swift.Float] = [:]) -> AlterCore.AvatarMatrix
  public func addBoneBlenderWeights(_ boneBlenderWeights: [Swift.String : Swift.Float]) -> AlterCore.AvatarMatrix
  public func addBoneBlenderPresetWeights(_ boneBlenderPresetWeights: [Swift.String : Swift.Float]) -> AlterCore.AvatarMatrix
  public func boneBlenders(_ fileSystem: AlterCore.FileSystem, _ itemRange: AlterCore.KotlinIntRange) -> AlterCore.Future<AlterCore.Try<Swift.Set<Swift.String>>>
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AvatarMatrix
  public static func == (lhs: AlterCore.AvatarMatrix, rhs: AlterCore.AvatarMatrix) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemReferenceDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ name: Swift.String, _ properties: [Swift.String : Swift.String] = [:])
  public var name: Swift.String {
    get
  }
  public var properties: [Swift.String : Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [Swift.String : Swift.String]
  public func doCopy(_ name: Swift.String, _ properties: [Swift.String : Swift.String] = [:]) -> AlterCore.ItemReferenceDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ItemReferenceDefinition
  public static func == (lhs: AlterCore.ItemReferenceDefinition, rhs: AlterCore.ItemReferenceDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TransformDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ translation: [Swift.Float]? = nil, _ rotation: [Swift.Float]? = nil, _ scale: [Swift.Float]? = nil)
  public var translation: [Swift.Float]? {
    get
  }
  public var rotation: [Swift.Float]? {
    get
  }
  public var scale: [Swift.Float]? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.Float]?
  public func component2() -> [Swift.Float]?
  public func component3() -> [Swift.Float]?
  public func doCopy(_ translation: [Swift.Float]? = nil, _ rotation: [Swift.Float]? = nil, _ scale: [Swift.Float]? = nil) -> AlterCore.TransformDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.TransformDefinition
  public static func == (lhs: AlterCore.TransformDefinition, rhs: AlterCore.TransformDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LoadedAvatarMatrix : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var sources: Swift.Set<AlterCore.Path> {
    get
  }
  public var matrix: AlterCore.AvatarMatrix {
    get
  }
  public static func == (lhs: AlterCore.LoadedAvatarMatrix, rhs: AlterCore.LoadedAvatarMatrix) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LoadedDebugAnimationFrame : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3, _ blendshapes: [Swift.String : Swift.Float])
  public var position: AlterCore.Vec3 {
    get
  }
  public var rotation: AlterCore.Quaternion {
    get
  }
  public var scale: AlterCore.Vec3 {
    get
  }
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public static func == (lhs: AlterCore.LoadedDebugAnimationFrame, rhs: AlterCore.LoadedDebugAnimationFrame) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LoadedDebugAnimation : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var length: Swift.Float {
    get
  }
  public func frameAt(_ sceneTime: Swift.Float) -> AlterCore.LoadedDebugAnimationFrame
  public static func fromJson(_ data: Swift.String) -> AlterCore.Try<AlterCore.LoadedDebugAnimation>
  public static func == (lhs: AlterCore.LoadedDebugAnimation, rhs: AlterCore.LoadedDebugAnimation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Timer : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var elapsed: Swift.Double {
    get
  }
  public func tick() -> AlterCore.Timer
  public static func start() -> AlterCore.Timer
  public static func == (lhs: AlterCore.Timer, rhs: AlterCore.Timer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FPS : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ interval: Swift.Double)
  @discardableResult
  public func tick(_ consumer: ((Swift.Double) -> Swift.Void)?) -> Swift.Double
  public static func == (lhs: AlterCore.FPS, rhs: AlterCore.FPS) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TickerMapper {
  associatedtype T
  var _wrappedTickerMapper: Swift.AnyObject { get }
  func invoke(_ value: Self.T, _ tickCount: Swift.Int, _ elapsed: Swift.Double) -> Self.T
}
@_hasMissingDesignatedInitializers public class TickerMapperWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.TickerMapper {
  public typealias T = T
  public var _wrappedTickerMapper: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func invoke(_ value: T, _ tickCount: Swift.Int, _ elapsed: Swift.Double) -> T
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Ticker : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ interval: Swift.Double)
  public func tick<T, TTickerMapper>(_ value: T, _ mapper: TTickerMapper) -> T where T == TTickerMapper.T, TTickerMapper : AlterCore.TickerMapper
  public func tick<T>(_ value: T, _ mapper_: @escaping (T) -> T) -> T
  public static func == (lhs: AlterCore.Ticker, rhs: AlterCore.Ticker) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinArray<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> T)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> T
  public func iterator<TKotlinIterator>() -> TKotlinIterator where T == TKotlinIterator.T, TKotlinIterator : AlterCore.KotlinIterator
  public func set(_ index: Swift.Int, _ value: T)
  public func flatten() -> AlterCore.KotlinFloatArray where T : AlterCore.KotlinFloatArray
  public static func == (lhs: AlterCore.KotlinArray<T>, rhs: AlterCore.KotlinArray<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinFloatArray : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ size: Swift.Int)
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Float)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Float
  public func iterator() -> AlterCore.KotlinFloatIterator
  public func set(_ index: Swift.Int, _ value: Swift.Float)
  public static func == (lhs: AlterCore.KotlinFloatArray, rhs: AlterCore.KotlinFloatArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinIntArray : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ size: Swift.Int)
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Int)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Int
  public func iterator() -> AlterCore.KotlinIntIterator
  public func set(_ index: Swift.Int, _ value: Swift.Int)
  public static func == (lhs: AlterCore.KotlinIntArray, rhs: AlterCore.KotlinIntArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinPair<A, B> : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ first: A, _ second: B)
  public var first: A {
    get
  }
  public var second: B {
    get
  }
  public func component1() -> A
  public func component2() -> B
  public func doCopy(_ first: A, _ second: B) -> AlterCore.KotlinPair<A, B>
  public func equals(_ other: Any?) -> Swift.Bool
  public func hashCode() -> Swift.Int
  public func toString() -> Swift.String
  public static func == (lhs: AlterCore.KotlinPair<A, B>, rhs: AlterCore.KotlinPair<A, B>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinThrowable : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ message: Swift.String?)
  public convenience init(_ cause: AlterCore.KotlinThrowable?)
  public convenience init()
  public convenience init(_ message: Swift.String?, _ cause: AlterCore.KotlinThrowable?)
  public var cause: AlterCore.KotlinThrowable? {
    get
  }
  public var message: Swift.String? {
    get
  }
  public func getStackTrace() -> AlterCore.KotlinArray<Swift.String>
  public func printStackTrace()
  public static func == (lhs: AlterCore.KotlinThrowable, rhs: AlterCore.KotlinThrowable) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinException : AlterCore.KotlinThrowable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public convenience init(_ message: Swift.String?)
  public convenience init(_ message: Swift.String?, _ cause: AlterCore.KotlinThrowable?)
  public convenience init(_ cause: AlterCore.KotlinThrowable?)
  public static func == (lhs: AlterCore.KotlinException, rhs: AlterCore.KotlinException) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinByteArray : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ size: Swift.Int)
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.CChar)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Int8
  public func iterator() -> AlterCore.KotlinByteIterator
  public func set(_ index: Swift.Int, _ value: Swift.Int8)
  public static func == (lhs: AlterCore.KotlinByteArray, rhs: AlterCore.KotlinByteArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Kotlinx_serialization_coreSerializationStrategy {
  associatedtype T
  var _wrappedKotlinx_serialization_coreSerializationStrategy: Swift.AnyObject { get }
  var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor { get }
  func serialize(_ encoder: AlterCore.Kotlinx_serialization_coreEncoder, _ value: Self.T)
}
public typealias SerializationStrategy = AlterCore.Kotlinx_serialization_coreSerializationStrategy
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerializationStrategyWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreSerializationStrategy {
  public typealias T = T
  public var _wrappedKotlinx_serialization_coreSerializationStrategy: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor {
    get
  }
  public func serialize(_ encoder: AlterCore.Kotlinx_serialization_coreEncoder, _ value: T)
  @objc deinit
}
public typealias SerializationStrategyWrapper = AlterCore.Kotlinx_serialization_coreSerializationStrategyWrapper
public protocol Kotlinx_serialization_coreDeserializationStrategy {
  associatedtype T
  var _wrappedKotlinx_serialization_coreDeserializationStrategy: Swift.AnyObject { get }
  var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor { get }
  func deserialize(_ decoder: AlterCore.Kotlinx_serialization_coreDecoder) -> Self.T
}
public typealias DeserializationStrategy = AlterCore.Kotlinx_serialization_coreDeserializationStrategy
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreDeserializationStrategyWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreDeserializationStrategy {
  public typealias T = T
  public var _wrappedKotlinx_serialization_coreDeserializationStrategy: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor {
    get
  }
  public func deserialize(_ decoder: AlterCore.Kotlinx_serialization_coreDecoder) -> T
  @objc deinit
}
public typealias DeserializationStrategyWrapper = AlterCore.Kotlinx_serialization_coreDeserializationStrategyWrapper
public protocol Kotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, AlterCore.Kotlinx_serialization_coreSerializationStrategy {
  associatedtype T
  var _wrappedKotlinx_serialization_coreKSerializer: Swift.AnyObject { get }
}
public typealias KSerializer = AlterCore.Kotlinx_serialization_coreKSerializer
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreKSerializerWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreKSerializer {
  public typealias T = T
  public var _wrappedKotlinx_serialization_coreKSerializer: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinx_serialization_coreSerializationStrategy: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinx_serialization_coreDeserializationStrategy: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor {
    get
  }
  public func serialize(_ encoder: AlterCore.Kotlinx_serialization_coreEncoder, _ value: T)
  public func deserialize(_ decoder: AlterCore.Kotlinx_serialization_coreDecoder) -> T
  @objc deinit
}
public typealias KSerializerWrapper = AlterCore.Kotlinx_serialization_coreKSerializerWrapper
public protocol Kotlinx_serialization_coreSerialFormat {
  var _wrappedKotlinx_serialization_coreSerialFormat: Swift.AnyObject { get }
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
}
public typealias SerialFormat = AlterCore.Kotlinx_serialization_coreSerialFormat
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerialFormatWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreSerialFormat {
  public var _wrappedKotlinx_serialization_coreSerialFormat: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  @objc deinit
}
public typealias SerialFormatWrapper = AlterCore.Kotlinx_serialization_coreSerialFormatWrapper
public protocol Kotlinx_serialization_coreStringFormat : AlterCore.Kotlinx_serialization_coreSerialFormat {
  var _wrappedKotlinx_serialization_coreStringFormat: Swift.AnyObject { get }
  func decodeFromString<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ string: Swift.String) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  func encodeToString<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) -> Swift.String where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
}
public typealias StringFormat = AlterCore.Kotlinx_serialization_coreStringFormat
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreStringFormatWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreStringFormat {
  public var _wrappedKotlinx_serialization_coreStringFormat: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinx_serialization_coreSerialFormat: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func decodeFromString<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ string: Swift.String) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func encodeToString<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) -> Swift.String where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  @objc deinit
}
public typealias StringFormatWrapper = AlterCore.Kotlinx_serialization_coreStringFormatWrapper
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_jsonJson : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.Kotlinx_serialization_coreStringFormat {
  public var _wrappedKotlinx_serialization_coreStringFormat: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinx_serialization_coreSerialFormat: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ configuration: AlterCore.Kotlinx_serialization_jsonJsonConfiguration, _ serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule)
  public var configuration: AlterCore.Kotlinx_serialization_jsonJsonConfiguration {
    get
  }
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func decodeFromJsonElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ element: AlterCore.Kotlinx_serialization_jsonJsonElement) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func decodeFromString<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ string: Swift.String) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func encodeToJsonElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) -> AlterCore.Kotlinx_serialization_jsonJsonElement where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeToString<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) -> Swift.String where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func parseToJsonElement(_ string: Swift.String) -> AlterCore.Kotlinx_serialization_jsonJsonElement
  public static func == (lhs: AlterCore.Kotlinx_serialization_jsonJson, rhs: AlterCore.Kotlinx_serialization_jsonJson) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public typealias Json = AlterCore.Kotlinx_serialization_jsonJson
public protocol KotlinIterator {
  associatedtype T
  var _wrappedKotlinIterator: Swift.AnyObject { get }
  func hasNext() -> Swift.Bool
  func next() -> Self.T
}
@_hasMissingDesignatedInitializers public class KotlinIteratorWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.KotlinIterator {
  public typealias T = T
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func hasNext() -> Swift.Bool
  public func next() -> T
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinIntProgression : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var first: Swift.Int {
    get
  }
  public var last: Swift.Int {
    get
  }
  public var step: Swift.Int {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func isEmpty() -> Swift.Bool
  public func iterator() -> AlterCore.KotlinIntIterator
  public static func == (lhs: AlterCore.KotlinIntProgression, rhs: AlterCore.KotlinIntProgression) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol KotlinClosedRange {
  associatedtype T : AlterCore.KotlinComparable
  var _wrappedKotlinClosedRange: Swift.AnyObject { get }
  var endInclusive: Self.T { get }
  var start: Self.T { get }
  func contains(_ value: Self.T) -> Swift.Bool
  func isEmpty() -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class KotlinClosedRangeWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.KotlinClosedRange where T : AlterCore.KotlinComparable {
  public typealias T = T
  public var _wrappedKotlinClosedRange: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var endInclusive: T {
    get
  }
  public var start: T {
    get
  }
  public func contains(_ value: T) -> Swift.Bool
  public func isEmpty() -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinIntRange : AlterCore.KotlinIntProgression, AlterCore.KotlinClosedRange {
  public typealias T = Swift.Int
  public var _wrappedKotlinClosedRange: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public convenience init(_ start: Swift.Int, _ endInclusive: Swift.Int)
  public var endInclusive: Swift.Int {
    get
  }
  public var start: Swift.Int {
    get
  }
  public func contains(_ value: AlterCore.KotlinIntRange.T) -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinIntRange, rhs: AlterCore.KotlinIntRange) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  override public var description: Swift.String {
    get
  }
  override public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
extension Int : AlterCore.KotlinComparable {
  public typealias T = Swift.Int
  public var _wrappedKotlinComparable: Swift.AnyObject {
    get
  }
  public func compareTo(_ other: Swift.Int) -> Swift.Int
}
@_hasMissingDesignatedInitializers public class KotlinDoubleArray : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init(_ size: Swift.Int)
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Double)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Double
  public func iterator() -> AlterCore.KotlinDoubleIterator
  public func set(_ index: Swift.Int, _ value: Swift.Double)
  public static func == (lhs: AlterCore.KotlinDoubleArray, rhs: AlterCore.KotlinDoubleArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinFloatIterator : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.KotlinIterator {
  public typealias T = Swift.Float
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public func next() -> AlterCore.KotlinFloatIterator.T
  public func nextFloat() -> Swift.Float
  public func hasNext() -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinFloatIterator, rhs: AlterCore.KotlinFloatIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinIntIterator : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.KotlinIterator {
  public typealias T = Swift.Int
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public func next() -> AlterCore.KotlinIntIterator.T
  public func nextInt() -> Swift.Int
  public func hasNext() -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinIntIterator, rhs: AlterCore.KotlinIntIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinByteIterator : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.KotlinIterator {
  public typealias T = Swift.CChar
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public func next() -> AlterCore.KotlinByteIterator.T
  public func nextByte() -> Swift.Int8
  public func hasNext() -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinByteIterator, rhs: AlterCore.KotlinByteIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Kotlinx_serialization_coreEncoder {
  var _wrappedKotlinx_serialization_coreEncoder: Swift.AnyObject { get }
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
  func beginCollection(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ collectionSize: Swift.Int) -> AlterCore.Kotlinx_serialization_coreCompositeEncoder
  func beginStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreCompositeEncoder
  func encodeBoolean(_ value: Swift.Bool)
  func encodeByte(_ value: Swift.Int8)
  func encodeChar(_ value: Foundation.unichar)
  func encodeDouble(_ value: Swift.Double)
  func encodeEnum(_ enumDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int)
  func encodeFloat(_ value: Swift.Float)
  func encodeInline(_ inlineDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreEncoder
  func encodeInt(_ value: Swift.Int)
  func encodeLong(_ value: Swift.Int64)
  func encodeNotNullMark()
  func encodeNull()
  func encodeNullableSerializableValue<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T?) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  func encodeSerializableValue<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  func encodeShort(_ value: Swift.Int16)
  func encodeString(_ value: Swift.String)
}
public typealias Encoder = AlterCore.Kotlinx_serialization_coreEncoder
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreEncoderWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreEncoder {
  public var _wrappedKotlinx_serialization_coreEncoder: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func beginCollection(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ collectionSize: Swift.Int) -> AlterCore.Kotlinx_serialization_coreCompositeEncoder
  public func beginStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreCompositeEncoder
  public func encodeBoolean(_ value: Swift.Bool)
  public func encodeByte(_ value: Swift.Int8)
  public func encodeChar(_ value: Foundation.unichar)
  public func encodeDouble(_ value: Swift.Double)
  public func encodeEnum(_ enumDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int)
  public func encodeFloat(_ value: Swift.Float)
  public func encodeInline(_ inlineDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreEncoder
  public func encodeInt(_ value: Swift.Int)
  public func encodeLong(_ value: Swift.Int64)
  public func encodeNotNullMark()
  public func encodeNull()
  public func encodeNullableSerializableValue<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T?) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeSerializableValue<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeShort(_ value: Swift.Int16)
  public func encodeString(_ value: Swift.String)
  @objc deinit
}
public typealias EncoderWrapper = AlterCore.Kotlinx_serialization_coreEncoderWrapper
public protocol Kotlinx_serialization_coreSerialDescriptor {
  var _wrappedKotlinx_serialization_coreSerialDescriptor: Swift.AnyObject { get }
  var annotations: [AlterCore.KotlinAnnotation] { get }
  var elementsCount: Swift.Int { get }
  var isInline: Swift.Bool { get }
  var isNullable: Swift.Bool { get }
  var kind: AlterCore.Kotlinx_serialization_coreSerialKind { get }
  var serialName: Swift.String { get }
  func getElementAnnotations(_ index: Swift.Int) -> [AlterCore.KotlinAnnotation]
  func getElementDescriptor(_ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreSerialDescriptor
  func getElementIndex(_ name: Swift.String) -> Swift.Int
  func getElementName(_ index: Swift.Int) -> Swift.String
  func isElementOptional(_ index: Swift.Int) -> Swift.Bool
}
public typealias SerialDescriptor = AlterCore.Kotlinx_serialization_coreSerialDescriptor
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerialDescriptorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreSerialDescriptor {
  public var _wrappedKotlinx_serialization_coreSerialDescriptor: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var annotations: [AlterCore.KotlinAnnotation] {
    get
  }
  public var elementsCount: Swift.Int {
    get
  }
  public var isInline: Swift.Bool {
    get
  }
  public var isNullable: Swift.Bool {
    get
  }
  public var kind: AlterCore.Kotlinx_serialization_coreSerialKind {
    get
  }
  public var serialName: Swift.String {
    get
  }
  public func getElementAnnotations(_ index: Swift.Int) -> [AlterCore.KotlinAnnotation]
  public func getElementDescriptor(_ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreSerialDescriptor
  public func getElementIndex(_ name: Swift.String) -> Swift.Int
  public func getElementName(_ index: Swift.Int) -> Swift.String
  public func isElementOptional(_ index: Swift.Int) -> Swift.Bool
  @objc deinit
}
public typealias SerialDescriptorWrapper = AlterCore.Kotlinx_serialization_coreSerialDescriptorWrapper
public protocol Kotlinx_serialization_coreDecoder {
  var _wrappedKotlinx_serialization_coreDecoder: Swift.AnyObject { get }
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
  func beginStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreCompositeDecoder
  func decodeBoolean() -> Swift.Bool
  func decodeByte() -> Swift.Int8
  func decodeChar() -> Foundation.unichar
  func decodeDouble() -> Swift.Double
  func decodeEnum(_ enumDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  func decodeFloat() -> Swift.Float
  func decodeInline(_ inlineDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreDecoder
  func decodeInt() -> Swift.Int
  func decodeLong() -> Swift.Int64
  func decodeNotNullMark() -> Swift.Bool
  func decodeNull() -> Swift.Never?
  func decodeNullableSerializableValue<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy) -> T? where TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinx_serialization_coreDeserializationStrategy.T == T?
  func decodeSerializableValue<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  func decodeShort() -> Swift.Int16
  func decodeString() -> Swift.String
}
public typealias Decoder = AlterCore.Kotlinx_serialization_coreDecoder
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreDecoderWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreDecoder {
  public var _wrappedKotlinx_serialization_coreDecoder: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func beginStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreCompositeDecoder
  public func decodeBoolean() -> Swift.Bool
  public func decodeByte() -> Swift.Int8
  public func decodeChar() -> Foundation.unichar
  public func decodeDouble() -> Swift.Double
  public func decodeEnum(_ enumDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  public func decodeFloat() -> Swift.Float
  public func decodeInline(_ inlineDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreDecoder
  public func decodeInt() -> Swift.Int
  public func decodeLong() -> Swift.Int64
  public func decodeNotNullMark() -> Swift.Bool
  public func decodeNull() -> Swift.Never?
  public func decodeNullableSerializableValue<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy) -> T? where TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinx_serialization_coreDeserializationStrategy.T == T?
  public func decodeSerializableValue<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func decodeShort() -> Swift.Int16
  public func decodeString() -> Swift.String
  @objc deinit
}
public typealias DecoderWrapper = AlterCore.Kotlinx_serialization_coreDecoderWrapper
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerializersModule : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public func dumpTo(_ collector: AlterCore.Kotlinx_serialization_coreSerializersModuleCollector)
  public func getContextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ typeArgumentsSerializers: [TKotlinx_serialization_coreKSerializer]) -> TKotlinx_serialization_coreKSerializer? where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == Any?
  public func getPolymorphic<T, TKotlinKClass, TKotlinx_serialization_coreSerializationStrategy>(_ baseClass: TKotlinKClass, _ value: T) -> TKotlinx_serialization_coreSerializationStrategy? where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy, TKotlinKClass.T == TKotlinx_serialization_coreSerializationStrategy.T
  public func getPolymorphic<T, TKotlinKClass, TKotlinx_serialization_coreDeserializationStrategy>(_ baseClass: TKotlinKClass, _ serializedClassName: Swift.String?) -> TKotlinx_serialization_coreDeserializationStrategy? where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinKClass.T == TKotlinx_serialization_coreDeserializationStrategy.T
  public static func == (lhs: AlterCore.Kotlinx_serialization_coreSerializersModule, rhs: AlterCore.Kotlinx_serialization_coreSerializersModule) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public typealias SerializersModule = AlterCore.Kotlinx_serialization_coreSerializersModule
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_jsonJsonConfiguration : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var allowSpecialFloatingPointValues: Swift.Bool {
    get
  }
  public var allowStructuredMapKeys: Swift.Bool {
    get
  }
  public var classDiscriminator: Swift.String {
    get
  }
  public var coerceInputValues: Swift.Bool {
    get
  }
  public var encodeDefaults: Swift.Bool {
    get
  }
  public var explicitNulls: Swift.Bool {
    get
  }
  public var ignoreUnknownKeys: Swift.Bool {
    get
  }
  public var isLenient: Swift.Bool {
    get
  }
  public var prettyPrint: Swift.Bool {
    get
  }
  public var prettyPrintIndent: Swift.String {
    get
  }
  public var useAlternativeNames: Swift.Bool {
    get
  }
  public var useArrayPolymorphism: Swift.Bool {
    get
  }
  public static func == (lhs: AlterCore.Kotlinx_serialization_jsonJsonConfiguration, rhs: AlterCore.Kotlinx_serialization_jsonJsonConfiguration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public typealias JsonConfiguration = AlterCore.Kotlinx_serialization_jsonJsonConfiguration
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_jsonJsonElement : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public static func == (lhs: AlterCore.Kotlinx_serialization_jsonJsonElement, rhs: AlterCore.Kotlinx_serialization_jsonJsonElement) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public typealias JsonElement = AlterCore.Kotlinx_serialization_jsonJsonElement
@_hasMissingDesignatedInitializers public class KotlinDoubleIterator : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.KotlinIterator {
  public typealias T = Swift.Double
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public func next() -> AlterCore.KotlinDoubleIterator.T
  public func nextDouble() -> Swift.Double
  public func hasNext() -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinDoubleIterator, rhs: AlterCore.KotlinDoubleIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Kotlinx_serialization_coreCompositeEncoder {
  var _wrappedKotlinx_serialization_coreCompositeEncoder: Swift.AnyObject { get }
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
  func encodeBooleanElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Bool)
  func encodeByteElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int8)
  func encodeCharElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Foundation.unichar)
  func encodeDoubleElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Double)
  func encodeFloatElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Float)
  func encodeInlineElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreEncoder
  func encodeIntElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int)
  func encodeLongElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int64)
  func encodeNullableSerializableElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T?) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  func encodeSerializableElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  func encodeShortElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int16)
  func encodeStringElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.String)
  func endStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor)
  func shouldEncodeElementDefault(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Bool
}
public typealias CompositeEncoder = AlterCore.Kotlinx_serialization_coreCompositeEncoder
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreCompositeEncoderWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreCompositeEncoder {
  public var _wrappedKotlinx_serialization_coreCompositeEncoder: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func encodeBooleanElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Bool)
  public func encodeByteElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int8)
  public func encodeCharElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Foundation.unichar)
  public func encodeDoubleElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Double)
  public func encodeFloatElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Float)
  public func encodeInlineElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreEncoder
  public func encodeIntElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int)
  public func encodeLongElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int64)
  public func encodeNullableSerializableElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T?) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeSerializableElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeShortElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int16)
  public func encodeStringElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.String)
  public func endStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor)
  public func shouldEncodeElementDefault(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Bool
  @objc deinit
}
public typealias CompositeEncoderWrapper = AlterCore.Kotlinx_serialization_coreCompositeEncoderWrapper
public protocol KotlinAnnotation {
  var _wrappedKotlinAnnotation: Swift.AnyObject { get }
}
@_hasMissingDesignatedInitializers public class KotlinAnnotationWrapper : AlterCore.ConvertibleToKotlin, AlterCore.KotlinAnnotation {
  public var _wrappedKotlinAnnotation: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerialKind : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public convenience init()
  public func hash() -> Swift.UInt
  public static func == (lhs: AlterCore.Kotlinx_serialization_coreSerialKind, rhs: AlterCore.Kotlinx_serialization_coreSerialKind) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public typealias SerialKind = AlterCore.Kotlinx_serialization_coreSerialKind
public protocol Kotlinx_serialization_coreCompositeDecoder {
  var _wrappedKotlinx_serialization_coreCompositeDecoder: Swift.AnyObject { get }
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
  func decodeBooleanElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Bool
  func decodeByteElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int8
  func decodeCharElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Foundation.unichar
  func decodeCollectionSize(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  func decodeDoubleElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Double
  func decodeElementIndex(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  func decodeFloatElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Float
  func decodeInlineElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreDecoder
  func decodeIntElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int
  func decodeLongElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int64
  func decodeNullableSerializableElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ previousValue: T?) -> T? where TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinx_serialization_coreDeserializationStrategy.T == T?
  func decodeSequentially() -> Swift.Bool
  func decodeSerializableElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ previousValue: T?) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  func decodeShortElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int16
  func decodeStringElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.String
  func endStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor)
}
public typealias CompositeDecoder = AlterCore.Kotlinx_serialization_coreCompositeDecoder
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreCompositeDecoderWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreCompositeDecoder {
  public var _wrappedKotlinx_serialization_coreCompositeDecoder: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func decodeBooleanElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Bool
  public func decodeByteElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int8
  public func decodeCharElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Foundation.unichar
  public func decodeCollectionSize(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  public func decodeDoubleElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Double
  public func decodeElementIndex(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  public func decodeFloatElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Float
  public func decodeInlineElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreDecoder
  public func decodeIntElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int
  public func decodeLongElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int64
  public func decodeNullableSerializableElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ previousValue: T?) -> T? where TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinx_serialization_coreDeserializationStrategy.T == T?
  public func decodeSequentially() -> Swift.Bool
  public func decodeSerializableElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ previousValue: T?) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func decodeShortElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int16
  public func decodeStringElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.String
  public func endStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor)
  @objc deinit
}
public typealias CompositeDecoderWrapper = AlterCore.Kotlinx_serialization_coreCompositeDecoderWrapper
public protocol Kotlinx_serialization_coreSerializersModuleCollector {
  var _wrappedKotlinx_serialization_coreSerializersModuleCollector: Swift.AnyObject { get }
  func contextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ provider: @escaping ([TKotlinx_serialization_coreKSerializer]) -> TKotlinx_serialization_coreKSerializer) where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == Any?
  func contextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ serializer: TKotlinx_serialization_coreKSerializer) where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinKClass.T == TKotlinx_serialization_coreKSerializer.T
  func polymorphic<Base, Sub, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ baseClass: TKotlinKClass, _ actualClass: TKotlinKClass, _ actualSerializer: TKotlinx_serialization_coreKSerializer) where Base == TKotlinKClass.T, Sub == TKotlinx_serialization_coreKSerializer.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer
  func polymorphicDefault<Base, TKotlinKClass, TKotlinx_serialization_coreDeserializationStrategy>(_ baseClass: TKotlinKClass, _ defaultSerializerProvider: @escaping (Swift.String?) -> TKotlinx_serialization_coreDeserializationStrategy?) where Base == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinKClass.T == TKotlinx_serialization_coreDeserializationStrategy.T
}
public typealias SerializersModuleCollector = AlterCore.Kotlinx_serialization_coreSerializersModuleCollector
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerializersModuleCollectorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreSerializersModuleCollector {
  public var _wrappedKotlinx_serialization_coreSerializersModuleCollector: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func contextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ provider: @escaping ([TKotlinx_serialization_coreKSerializer]) -> TKotlinx_serialization_coreKSerializer) where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == Any?
  public func contextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ serializer: TKotlinx_serialization_coreKSerializer) where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinKClass.T == TKotlinx_serialization_coreKSerializer.T
  public func polymorphic<Base, Sub, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ baseClass: TKotlinKClass, _ actualClass: TKotlinKClass, _ actualSerializer: TKotlinx_serialization_coreKSerializer) where Base == TKotlinKClass.T, Sub == TKotlinx_serialization_coreKSerializer.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer
  public func polymorphicDefault<Base, TKotlinKClass, TKotlinx_serialization_coreDeserializationStrategy>(_ baseClass: TKotlinKClass, _ defaultSerializerProvider: @escaping (Swift.String?) -> TKotlinx_serialization_coreDeserializationStrategy?) where Base == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinKClass.T == TKotlinx_serialization_coreDeserializationStrategy.T
  @objc deinit
}
public typealias SerializersModuleCollectorWrapper = AlterCore.Kotlinx_serialization_coreSerializersModuleCollectorWrapper
public protocol KotlinKDeclarationContainer {
  var _wrappedKotlinKDeclarationContainer: Swift.AnyObject { get }
}
@_hasMissingDesignatedInitializers public class KotlinKDeclarationContainerWrapper : AlterCore.ConvertibleToKotlin, AlterCore.KotlinKDeclarationContainer {
  public var _wrappedKotlinKDeclarationContainer: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
}
public protocol KotlinKAnnotatedElement {
  var _wrappedKotlinKAnnotatedElement: Swift.AnyObject { get }
}
@_hasMissingDesignatedInitializers public class KotlinKAnnotatedElementWrapper : AlterCore.ConvertibleToKotlin, AlterCore.KotlinKAnnotatedElement {
  public var _wrappedKotlinKAnnotatedElement: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
}
public protocol KotlinKClassifier {
  var _wrappedKotlinKClassifier: Swift.AnyObject { get }
}
@_hasMissingDesignatedInitializers public class KotlinKClassifierWrapper : AlterCore.ConvertibleToKotlin, AlterCore.KotlinKClassifier {
  public var _wrappedKotlinKClassifier: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
}
public protocol KotlinKClass : AlterCore.KotlinKAnnotatedElement, AlterCore.KotlinKClassifier, AlterCore.KotlinKDeclarationContainer {
  associatedtype T
  var _wrappedKotlinKClass: Swift.AnyObject { get }
  var qualifiedName: Swift.String? { get }
  var simpleName: Swift.String? { get }
  func isInstance(_ value: Any?) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class KotlinKClassWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.KotlinKClass {
  public typealias T = T
  public var _wrappedKotlinKClass: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinKDeclarationContainer: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinKAnnotatedElement: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinKClassifier: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var qualifiedName: Swift.String? {
    get
  }
  public var simpleName: Swift.String? {
    get
  }
  public func isInstance(_ value: Any?) -> Swift.Bool
  @objc deinit
}
extension FaceTracker {
  public static func createVideoTracker() -> AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>
  public static func createImageTracker() -> AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>
  public func track(_ image: CoreVideo.CVPixelBuffer?) -> AlterCore.FaceTrackerResult?
  public func track(_ image: CoreMedia.CMSampleBuffer?) -> AlterCore.FaceTrackerResult?
  public func track(_ image: UIKit.UIImage?) -> AlterCore.FaceTrackerResult?
}
extension TrackerImage {
  public convenience init?(_ sampleBuffer: CoreMedia.CMSampleBuffer)
}
public class RecordedVideo {
  final public let filePath: Foundation.URL
  public init(_ path: Foundation.URL)
  public func saveToPhotos() -> AlterCore.Future<AlterCore.Try<Swift.String>>
  public func deleteVideo()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class BaseVideoRecorder : ObjectiveC.NSObject, AVFoundation.AVCaptureAudioDataOutputSampleBufferDelegate {
  public func startRecording() -> AlterCore.Try<Swift.Void>
  public func stopRecording() -> AlterCore.Future<AlterCore.Try<AlterCore.RecordedVideo>>
  public func stopRecording(after: Dispatch.DispatchTimeInterval) -> AlterCore.Future<AlterCore.Try<AlterCore.RecordedVideo>>
  @objc public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
  @objc deinit
  @objc override dynamic public init()
}
@objc @_hasMissingDesignatedInitializers public class VideoRecorder : AlterCore.BaseVideoRecorder {
  override public func startRecording() -> AlterCore.Try<Swift.Void>
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ViewRecorder : AlterCore.BaseVideoRecorder {
  override public func startRecording() -> AlterCore.Try<Swift.Void>
  override public func stopRecording() -> AlterCore.Future<AlterCore.Try<AlterCore.RecordedVideo>>
  @objc deinit
}
extension AvatarRenderer {
  public func startVideoRecording(_ resolution: (Swift.Int, Swift.Int), _ recordSound: Swift.Bool = false, _ desiredFps: Swift.Int = 30) -> AlterCore.Try<AlterCore.VideoRecorder>
}
extension AlterCore.FaceTrackerResult : Swift.Hashable {}
extension AlterCore.FaceTrackerWithResult : Swift.Hashable {}
extension AlterCore.FaceTrackerReprojectorResult : Swift.Hashable {}
extension AlterCore.ThumbnailConfigDefinition : Swift.Hashable {}
extension AlterCore.Path : Swift.Hashable {}
extension AlterCore.AvatarAnimationData : Swift.Hashable {}
extension AlterCore.AnimationReferenceDefinition : Swift.Hashable {}
extension AlterCore.AvatarMatrix : Swift.Hashable {}
extension AlterCore.ItemReferenceDefinition : Swift.Hashable {}
extension AlterCore.TransformDefinition : Swift.Hashable {}
extension AlterCore.KotlinPair : Swift.Hashable {}